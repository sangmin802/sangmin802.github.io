{"componentChunkName":"component---src-templates-blog-post-js","path":"/Study/Framework/next.js webpack/","result":{"data":{"site":{"siteMetadata":{"title":"SangMin 개발 이야기","author":"SangMin","siteUrl":"https://sangmin802.github.io","comment":{"disqusShortName":"","utterances":"sangmin802/sangmin802.github.io"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"82f25e9c-72d3-5086-9de4-6cdbdbb6a00b","excerpt":"대부분의 프레임워크들은 편리한 배포를 위해, 파일을 알아서 만들어준다. 따라서, 간단한 커맨드를 통해 빌드파일을 만들 수 있는데 이전에 , ,로 서버, 부터,  빌드환경까지 만들었던 생각을 해보면 참 편하긴 함.. 또한 그러한 기능을 제공한다. 문제발생 😡 앱을 로 개발해보는 과정에서, 는 모든 사용자에게 공통된 정보를 보여주기때문에, 메소드를 통해 정적 을 사용하기로 했다. 해당 앱은 로스트아크 공식 사이트 전투정보실에 생성된 돔을 가져와서 데이터를 재가공하기 때문에,  API…","html":"<p>대부분의 프레임워크들은 편리한 배포를 위해, <code class=\"language-text\">Webpack</code>파일을 알아서 만들어준다.</p>\n<p>따라서, 간단한 커맨드를 통해 빌드파일을 만들 수 있는데</p>\n<blockquote>\n<p>이전에 <code class=\"language-text\">Vanila JS</code>, <code class=\"language-text\">Node.js</code>,<code class=\"language-text\">Mysql</code>로 서버, <code class=\"language-text\">DB</code>부터, <code class=\"language-text\">Webpack</code> 빌드환경까지 만들었던 생각을 해보면 참 편하긴 함..</p>\n</blockquote>\n<p><code class=\"language-text\">Next.js</code>또한 그러한 기능을 제공한다.</p>\n<h2 id=\"문제발생-\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%EB%B0%9C%EC%83%9D-\" aria-label=\"문제발생  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제발생 😡</h2>\n<p><code class=\"language-text\">loa-hands</code>앱을 <code class=\"language-text\">Next.js</code>로 개발해보는 과정에서, <code class=\"language-text\">Home Route</code>는 모든 사용자에게 공통된 정보를 보여주기때문에, <code class=\"language-text\">getStaticProps</code>메소드를 통해 정적 <code class=\"language-text\">pre-rendering</code>을 사용하기로 했다.</p>\n<p>해당 앱은 로스트아크 공식 사이트 전투정보실에 생성된 돔을 가져와서 데이터를 재가공하기 때문에, <code class=\"language-text\">DOMParser</code> API를 사용하는데, 해당 API가 존재하지 않는다는 에러가 발생했다</p>\n<blockquote>\n<p>당연한것이, <code class=\"language-text\">DOMParser</code>는 돔이 구성되는 클라이언트? 측에서 존재하는 API이라고 알고있어서 서버상에서 작동되는 <code class=\"language-text\">getStaticProps</code>실행시에는 해당 API가 존재할 수 없었다.</p>\n</blockquote>\n<p>너무나도 고맙게도, <code class=\"language-text\">JSDOM</code>이라는 외부 모듈을 가져와서 서버상에서도 돔을 조작할 수 있도록 하였는데</p>\n<div style=\"text-align : center\">\n  <img src=\"/img/2021/02/01/1.PNG?raw=true\" alt=\"1\">\n</div>\n<p><strong>뭐야?</strong></p>\n<h2 id=\"두번의-번들링\" style=\"position:relative;\"><a href=\"#%EB%91%90%EB%B2%88%EC%9D%98-%EB%B2%88%EB%93%A4%EB%A7%81\" aria-label=\"두번의 번들링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>두번의 번들링</h2>\n<p><code class=\"language-text\">Next.js</code>는 개발중에도 가상의 서버를 통해 진행된다. 따라서, <code class=\"language-text\">npm run dev</code>메소드가 실행되면 가상의 서버가 실행되고, 작성했던 파일들이 번들링되어 화면을 그려주는 걸로 알고있었다.</p>\n<p><strong>하지만</strong> 알고보니 <code class=\"language-text\">Next.js</code>는 클라이언트상에서 한번 서버에서 한번 총 두번의 번들링 과정을 갖는다고 한다. 따라서, <code class=\"language-text\">JSDOM</code>을 통해 서버에서 돔을 조작할 수 있게 되었지만, 클라이언트단 에서는 <code class=\"language-text\">JSDOM</code>모듈이 사용하는 외부 모듈들을 실행시키지 못하는것이였다.</p>\n<p>너무 고맙게도, <code class=\"language-text\">Next.js</code>는 <code class=\"language-text\">webpack</code>메소드를 통해, <code class=\"language-text\">Webpack</code>파일을 수정할 수 있었는데</p>\n<div style=\"text-align : center\">\n  <img src=\"/img/2021/02/01/2.PNG?raw=true\" alt=\"2\">\n</div>\n<p>해당 메소드를 사용하여 서버환경이 아닐경우, 해당 노드들을 사용하지 않게하였고, 정상적으로 작동되었다.</p>\n<h2 id=\"next-redux-wrapper\" style=\"position:relative;\"><a href=\"#next-redux-wrapper\" aria-label=\"next redux wrapper permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>next-redux-wrapper</h2>\n<p><code class=\"language-text\">Next.js</code>에서도 <code class=\"language-text\">redux</code>를 사용할 수 있는데, 기존 <code class=\"language-text\">React.js</code>와는 다르게 하나의 모듈이 더 필요하다. <code class=\"language-text\">next-redux-wrapper</code></p>\n<div style=\"text-align : center\">\n  <img src=\"/img/2021/02/01/3.PNG?raw=true\" alt=\"3\">\n</div>\n<p><code class=\"language-text\">Next.js</code>는 <code class=\"language-text\">SEO</code>최적화를 위한 <code class=\"language-text\">pre-rendering</code>이 가능한 프레임워크로서 개발자의 필요에 따라 특정 라우트를 서버에서 미리 생성하게 할 수 있다. 그렇게 된다면, 클라이언트단에서 페이지 라우팅을 할 때마다 새로운 페이지를 받아오면서 새로운 <code class=\"language-text\">Redux Store</code>를 생성하게되는데, 이때 필요한 것이 <code class=\"language-text\">next-redux-wrapper</code>이다.</p>\n<blockquote>\n<p><code class=\"language-text\">next-redux-wrapper</code>의 사용법은 해당 깃허브주소에 잘 나와있다.</p>\n</blockquote>\n<p>이 모듈을 사용해야만 <code class=\"language-text\">getStaticProps</code>와 같이 서버에서 실행되는 메소드 내부에서도 <code class=\"language-text\">Redux Hook</code>을 사용할 수 있다.</p>\n<div style=\"text-align : center\">\n  <img src=\"/img/2021/02/01/4.PNG?raw=true\" alt=\"4\">\n</div>\n<p><code class=\"language-text\">Reducer</code>에서는 기존 <code class=\"language-text\">React.js</code>와 다르게 <code class=\"language-text\">HYDRATE</code>이라는 타입이 추가되는데, 이 과정에서 서버에서 가지고있는 <code class=\"language-text\">store</code>정보와 클라이언트에서 갖고있는 <code class=\"language-text\">store</code>의 정보를 하나로 합친다.</p>\n<p>이로인해, 위에서의 상황을 해결하여 완성한 <code class=\"language-text\">pre-rendering</code>을 통해 받은 데이터를 클라이언트에서 그대로 사용할 수 있다.</p>\n<div style=\"text-align : center\">\n  <img src=\"/img/2021/02/01/5.PNG?raw=true\" alt=\"5\">\n</div>\n<p>터미널을 통해 해당 과정을 지켜보면</p>\n<div style=\"text-align : center\">\n  <img src=\"/img/2021/02/01/6.PNG?raw=true\" alt=\"6\">\n</div>\n<ol>\n<li>서버에서 기본값으로 구성된 <code class=\"language-text\">store</code>가 생성되고</li>\n<li>\n<p>서버에서 <code class=\"language-text\">dispatch</code>메소드를 통해 <code class=\"language-text\">store</code>에 변화를 주게된다.</p>\n<blockquote>\n<p>이 때, 보내지는 정보들은 <code class=\"language-text\">JSON</code>형식이 아니면 에러가 발생하더라..</p>\n</blockquote>\n</li>\n<li>\n<p><code class=\"language-text\">App</code>을 감싸준 <code class=\"language-text\">wrapper</code>에서 서버에서 생성된 <code class=\"language-text\">store</code>를 확인하는것 같다.</p>\n<blockquote>\n<p><code class=\"language-text\">wrapper</code>와 관련된것은 <code class=\"language-text\">next-redux-wrapper</code>의 공식 깃허브 디렉토리를 가보면 잘 나와있다.</p>\n</blockquote>\n</li>\n</ol>\n<p>이후, 정적파일로 빌드해보면 <code class=\"language-text\">index.html</code>에 <code class=\"language-text\">pre-rendering</code>이 잘 되어있음을 확인할 수 있다.</p>\n<p><strong>야호!🥳</strong></p>","frontmatter":{"title":"Next.js Webpack","date":"February 01, 2021"}}},"pageContext":{"slug":"/Study/Framework/next.js webpack/","previous":{"fields":{"slug":"/Study/Framework/next.js route/"},"frontmatter":{"title":"Next.js Route","category":"Study","draft":false,"tag":"Framework"}},"next":{"fields":{"slug":"/Study/Framework/next.js loa-hands/"},"frontmatter":{"title":"Next.js Loa-Hands","category":"Study","draft":false,"tag":"Framework"}}}},"staticQueryHashes":["3128451518","3665928227","479399088","479399088"]}