{"componentChunkName":"component---src-templates-blog-post-js","path":"/Study/CS/browser-parser-blocking/","result":{"data":{"site":{"siteMetadata":{"title":"SangMin 개발 이야기","author":"SangMin","siteUrl":"https://sangmin802.github.io","comment":{"disqusShortName":"","utterances":"sangmin802/sangmin802.github.io"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"1a8a6ef2-d582-5a9b-be93-c4bd971da456","excerpt":"Parsing Blocking 브라우저의 는 인  코드로부터 를 구성하도록 해주는 를 제공한다. 흔히 아는  대부분의 웹 어플리케이션은 , , 가 함께해야 완전하다. 즉, 을 하다보면 되거나 외부 파일로 연결된 , 를 만나게 된다. 그 외에도, 와 같이 외부 링크를 다운받아야 하는 경우도 있다. 을 포함한 대부분의 브라우저 렌더링의 작업들은 메인스레드에서 진행이 된다. 그렇다면, 중간에 다른 작업이 필요한 경우, 어떠한 우선순위로 작업을 수행할까 Parser-Blocking Scripts…","html":"<h2 id=\"parsing-blocking\" style=\"position:relative;\"><a href=\"#parsing-blocking\" aria-label=\"parsing blocking permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parsing Blocking</h2>\n<p>브라우저의 <code class=\"language-text\">Web API</code>는 <code class=\"language-text\">text/html</code>인 <code class=\"language-text\">HTML</code> 코드로부터 <code class=\"language-text\">DOM Tree</code>를 구성하도록 해주는 <code class=\"language-text\">DOM Parser</code>를 제공한다.</p>\n<blockquote>\n<p>흔히 아는 <code class=\"language-text\">new DOMParser()</code></p>\n</blockquote>\n<p>대부분의 웹 어플리케이션은 <code class=\"language-text\">HTML</code>, <code class=\"language-text\">CSS</code>, <code class=\"language-text\">JS</code>가 함께해야 완전하다.</p>\n<p>즉, <code class=\"language-text\">HTML</code>을 <code class=\"language-text\">parsing</code>하다보면 <code class=\"language-text\">embedded</code>되거나 외부 파일로 연결된 <code class=\"language-text\">CSS</code>, <code class=\"language-text\">JS</code>를 만나게 된다.</p>\n<blockquote>\n<p>그 외에도, <code class=\"language-text\">img</code>와 같이 외부 링크를 다운받아야 하는 경우도 있다.</p>\n</blockquote>\n<div style=\"margin : 0 auto; text-align : center\">\n  <img src=\"/img/2021/07/27/parser-blocking1.png\" alt=\"1\">\n</div>\n<p><code class=\"language-text\">DOM Parsing</code>을 포함한 대부분의 브라우저 렌더링의 작업들은 메인스레드에서 진행이 된다.</p>\n<p>그렇다면, 중간에 다른 작업이 필요한 경우, 어떠한 우선순위로 작업을 수행할까</p>\n<h2 id=\"parser-blocking-scripts\" style=\"position:relative;\"><a href=\"#parser-blocking-scripts\" aria-label=\"parser blocking scripts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parser-Blocking Scripts</h2>\n<p>이름에서부터 알 수 있는것처럼, <code class=\"language-text\">Javascript</code>의 파일 또는 코드들을 의미한다.</p>\n<p>기본적으로 <code class=\"language-text\">script</code>태그를 만나게 된다면, 해당 스크립트를 먼저 일고, 실행시킨 다음 나머지 <code class=\"language-text\">HTML</code>을 파싱한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>Hello<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span><span class=\"token operator\">...</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>Parse stop<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span></code></pre></div>\n<p>따라서 위와같은 <code class=\"language-text\">embedded Script</code>들은 모두 메인스레드의 <code class=\"language-text\">HTML</code> 파싱을 중단시키고, 모든 <code class=\"language-text\">embedded Script</code>들은 <code class=\"language-text\">Parser-Blocking</code>이라고 불린다.</p>\n<p>그렇다면, 왜 <code class=\"language-text\">Script</code>파일을 만나게된다면, 파싱을 중단할까?</p>\n<p>기본적으로 개발자들은 <code class=\"language-text\">DOM</code>에 이벤트를 부여하거나, 조작하고 변경할수 있는데, 이것이 가능한것이</p>\n<p>브라우저에서 형성된 <code class=\"language-text\">DOM</code>은 <code class=\"language-text\">DOM API</code>를 통해 <code class=\"language-text\">Javascript</code> 환경에 노출시키기 때문이다.</p>\n<blockquote>\n<p>즉, <code class=\"language-text\">Javascript</code>의 문법이 이전에 형성되어있는 <code class=\"language-text\">DOM</code>의 요소를 바꿀 수 있기 때문</p>\n</blockquote>\n<p>하지만, <code class=\"language-text\">DOM</code>의 요소를 바꾸지 않는 <code class=\"language-text\">Script</code> 인데도 불구하고, 다운로드 하는 동안 <code class=\"language-text\">DOM Parser</code>의 작업이 멈추게 된다는점은 그만큼의 시간이 더 든다는 점이다.</p>\n<h3 id=\"async-defer\" style=\"position:relative;\"><a href=\"#async-defer\" aria-label=\"async defer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>async defer</h3>\n<p>브라우저가 <code class=\"language-text\">HTML</code>을 파싱하면서, <code class=\"language-text\">Script</code>를 만났을 때에 로드하는 방식을 알려주는 방법이 있다.</p>\n<blockquote>\n<p><code class=\"language-text\">embedded</code>를 제외한</p>\n</blockquote>\n<p><code class=\"language-text\">script</code> 요소에 <code class=\"language-text\">async</code> 혹은 <code class=\"language-text\">defer</code>속성을 할당해주는 것이다.</p>\n<ul>\n<li>아무속성x : <code class=\"language-text\">DOM</code> 파싱 중 <code class=\"language-text\">script</code>를 만나면 <code class=\"language-text\">DOM</code> 파싱 중단 > <code class=\"language-text\">script</code> 파일 다운로드 > <code class=\"language-text\">script</code> 실행 > 나머지 <code class=\"language-text\">DOM</code> 파싱</li>\n<li>async : <code class=\"language-text\">DOM</code>파싱과 <code class=\"language-text\">script</code>파일 다운로드 동시 진행 > <code class=\"language-text\">script</code>다운로드 완료 시 <code class=\"language-text\">DOM</code>파싱 중단 후 <code class=\"language-text\">script</code> 실행 > 나머지 <code class=\"language-text\">DOM</code> 파싱</li>\n<li>defer : <code class=\"language-text\">DOM</code>파싱과 <code class=\"language-text\">script</code>파일 다운로드 동시 진행 > <code class=\"language-text\">script</code>다운로드 완료되어도 <code class=\"language-text\">DOM</code>파싱 진행 > <code class=\"language-text\">DOM</code>파싱 종료 후 스크립트 실행</li>\n</ul>\n<p>내 브라우저에서 임의로 테스트해보려 했지만, 어지간한 양이 아니라면, 네트워크 속도 때문에 확인하기가 어려웠다..</p>\n<p>따라서 좋은 예시를 보여주고 있는 사이트를 통해 보는것이 좋을듯 하다!</p>\n<ul>\n<li><a href=\"https://sangcho.tistory.com/entry/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-Rendering-3-Rendering-Process-in-browsers?category=740188\">normal vs async vs defer</a></li>\n</ul>\n<h2 id=\"parser-blocking-no-render-blocking-css\" style=\"position:relative;\"><a href=\"#parser-blocking-no-render-blocking-css\" aria-label=\"parser blocking no render blocking css permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parser-Blocking? No! Render-Blocking CSS</h2>\n<p><code class=\"language-text\">script</code>요소외의 것들은 <code class=\"language-text\">DOM</code>파싱을 막지 않는다. 따라서, <code class=\"language-text\">CSS</code>는 <code class=\"language-text\">DOM</code>파싱을 <strong>직접적</strong>으로 막지는 않는다.</p>\n<p><code class=\"language-text\">embedded</code> 스타일이나, <code class=\"language-text\">inline</code> 스타일의 경우 종종 <code class=\"language-text\">DOM</code>파싱을 막는 경우가 있다.</p>\n<p><code class=\"language-text\">embedded</code>스타일의 종료를 알리는 <code class=\"language-text\">&lt;/style&gt;</code>을 만났을 때, <code class=\"language-text\">DOM</code>파싱이 멈추고 해당 구간의 <code class=\"language-text\">embedded</code>스타일을 파싱하여 <code class=\"language-text\">CSSOM</code>트리를 업데이트한다. 그 이후에 <code class=\"language-text\">DOM</code>파싱이 재개된다.</p>\n<p>왜일까?</p>\n<p>이전 포스트에서 <code class=\"language-text\">CSSOM</code>은 <code class=\"language-text\">cascading</code>이라는 룰을 기준으로 <code class=\"language-text\">CSSOM</code>트리를 형성한다고 했다.</p>\n<p>그 특징중 하나가 중요했는데,</p>\n<ol>\n<li>\n<p>계단식 스타일</p>\n<blockquote>\n<p>동일한 속성의 스타일이라면 최 하단의 스타일이 적용됨</p>\n</blockquote>\n</li>\n</ol>\n<p>이와같은 이유 때문에, <code class=\"language-text\">DOM Tree</code>는 점진적으로 구성되지만, <code class=\"language-text\">CSSOM</code>은 그런 방식으로는 불가능하다.</p>\n<p>만약 <code class=\"language-text\">CSSOM</code>을 점진적으로 구성하게 된다면, 동일한 요소의 동일한 속성에 다른 값으로 부여되는 코드가 여러 줄에 존재할 수 있고,\n하나의 속성 변경이 여러 요소에 영향을 줄 수 있기 때문이다.</p>\n<p>그렇게된다면 계속해서 <code class=\"language-text\">CSSOM</code>이 업데이트됨에 따라 <code class=\"language-text\">Render Tree</code>가 여러번 렌더링이 되어 많은 비용이 소요되고, 사용자에게 좋지않은 경험을 줄 수 있다.</p>\n<p><code class=\"language-text\">styleSheet</code>의 경우 <code class=\"language-text\">embedded</code>, <code class=\"language-text\">inline</code>스타일과 다르게 백그라운드에서 완전히 다운로드 받을 수 있어 <code class=\"language-text\">DOM</code>파싱을 중단시키지는 않는다.</p>\n<p>다만, <code class=\"language-text\">styledSheet</code>도 위의 룰로 인해 <code class=\"language-text\">styleSheet</code>를 처리하고 딱 한번만 <code class=\"language-text\">CSSOM</code>트리를 수정한다. 그리고 수정된 <code class=\"language-text\">CSSOM</code>트리를 통해 <code class=\"language-text\">Render Tree</code>가 업데이트된다.</p>\n<p><code class=\"language-text\">CSS</code>가 <code class=\"language-text\">Render-Blocking</code> 자원이라고 불리는 이유이다. 스타일 요소가 읽히는 동안에는 <code class=\"language-text\">Render Tree</code> 구성이 중지된다.</p>\n<blockquote>\n<p>마지막에 한번만 <code class=\"language-text\">CSSOM</code> 수정 > <code class=\"language-text\">Render Tree</code> 업데이트가 이뤄지기 때문</p>\n</blockquote>\n<p>하지만, <code class=\"language-text\">Render Tree</code>의 구성이 멈출뿐이지, <code class=\"language-text\">DOM</code>을 파싱하는것은 멈추지 않는다.</p>\n<p><code class=\"language-text\">DOM</code> 파싱이 종료되어 <code class=\"language-text\">DOM Tree</code>가 완성되었다고 하더라도, <code class=\"language-text\">CSSOM</code>트리가 아직 완성되어있지 않는다면 <code class=\"language-text\">Render Tree</code>를 구성하지 않는다.</p>\n<blockquote>\n<p>생각해보면 당연한것이, <code class=\"language-text\">CSS</code>작업이 완료되지 않았는데 화면에 보여질 요소들을 형성한다는것이 말이안됨</p>\n</blockquote>\n<p>위와 같은 상황을 <code class=\"language-text\">CRP</code>가 멈춘 상황이라고 한다.(화면을 그리지 않음)</p>\n<blockquote>\n<p>CRP - Critical Rendering Path 브라우저 렌더링 경로</p>\n</blockquote>\n<p>또한, <code class=\"language-text\">styleSheet</code>를 백그라운드에서 다운로드 받을 수 있기 때문에, <code class=\"language-text\">HTML</code>을 파싱하면서 <code class=\"language-text\">script</code>또한 읽힐 수 있다.</p>\n<p>경우에 따라 읽힌 <code class=\"language-text\">script</code>는 실행될 수 있는데, 브라우저는 이전의 <code class=\"language-text\">styleSheet</code>가 파싱되어있지 않다면 다운로드된 <code class=\"language-text\">script</code>를 <code class=\"language-text\">block</code>한다고 한다. 이를, <code class=\"language-text\">Script-Blocking stylesheet</code> 또는 <code class=\"language-text\">Script-Blocking CSS</code> 라고 한다.</p>\n<blockquote>\n<p><code class=\"language-text\">JS</code>로 <code class=\"language-text\">DOM Tree</code> 요소의 스타일을 수집한 후에 <code class=\"language-text\">CSSOM</code>이 업데이트 되어 <code class=\"language-text\">DOM Tree</code>가 변경된다면 <code class=\"language-text\">JS</code>는 잘못된 스타일 속성을 가질 수 있기 때문</p>\n</blockquote>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<p><code class=\"language-text\">Parse</code> 중단, <code class=\"language-text\">Render</code>중단에 따른 <code class=\"language-text\">CRP</code>가 멈추는상황들을 알아보았다.</p>\n<p>위와같은 상황들을 모두 거치고 완성된 <code class=\"language-text\">Render Tree</code>는 어떠한 과정을 거쳐 마침내 사용자에게 보여지는지 다음 포스트로 이어서 알아보도록 하자.</p>\n<h2 id=\"참조\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EC%A1%B0\" aria-label=\"참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참조</h2>\n<ul>\n<li><a href=\"https://sangcho.tistory.com/entry/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-Rendering-3-Rendering-Process-in-browsers?category=740188\">parse-blocking</a></li>\n<li><a href=\"https://stackoverflow.com/questions/37759321/parser-blocking-vs-render-blocking\">parse-blocking vs render-blocking</a></li>\n<li><a href=\"https://developers.google.com/web/updates/2018/09/inside-browser-part3\">modern web browser</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path\">critical rendering path</a></li>\n</ul>","frontmatter":{"title":"💻 브라우저 렌더링 - CRP 멈춰!","date":"July 27, 2021"}}},"pageContext":{"slug":"/Study/CS/browser-parser-blocking/","previous":{"fields":{"slug":"/Study/CS/browser-construction/"},"frontmatter":{"title":"💻 브라우저 렌더링 - 파싱단계 construction","category":"Study","draft":false,"tag":"CS"}},"next":{"fields":{"slug":"/Study/CS/browser-operation/"},"frontmatter":{"title":"💻 브라우저 렌더링 - 시각화 단계 operation","category":"Study","draft":false,"tag":"CS"}}}},"staticQueryHashes":["3128451518","3665928227","479399088","479399088"]}