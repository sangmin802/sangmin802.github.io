{"componentChunkName":"component---src-templates-blog-post-js","path":"/Study/Think/useState,redux,useReducer/","result":{"data":{"site":{"siteMetadata":{"title":"SangMin 개발 이야기","author":"SangMin","siteUrl":"https://sangmin802.github.io","comment":{"disqusShortName":"","utterances":"sangmin802/sangmin802.github.io"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"f4933837-5286-57b9-9be2-9e16e150e3a5","excerpt":"에서 기본적으로 제공되는 를 사용하여 상태값과, 상태값을 업데이트할 수 있는 메소드를 생성할 수 있다. 아무렇지도 않게 사용해오던 에 알지못했던 세부적인 내용이 있었고, 이 세부적인 내용이 이전에 개인프로젝트를 하면서 발생했던 에러와 큰 관련이 있어 알아보게 되었다. setState…","html":"<p><code class=\"language-text\">React</code>에서 기본적으로 제공되는 <code class=\"language-text\">useState</code>를 사용하여 상태값과, 상태값을 업데이트할 수 있는 <code class=\"language-text\">setState</code>메소드를 생성할 수 있다.</p>\n<p>아무렇지도 않게 사용해오던 <code class=\"language-text\">setState</code>에 알지못했던 세부적인 내용이 있었고, 이 세부적인 내용이 이전에 개인프로젝트를 하면서 발생했던 에러와 큰 관련이 있어 알아보게 되었다.</p>\n<h2 id=\"setstate는-의존성-배열에서-필요가-없다\" style=\"position:relative;\"><a href=\"#setstate%EB%8A%94-%EC%9D%98%EC%A1%B4%EC%84%B1-%EB%B0%B0%EC%97%B4%EC%97%90%EC%84%9C-%ED%95%84%EC%9A%94%EA%B0%80-%EC%97%86%EB%8B%A4\" aria-label=\"setstate는 의존성 배열에서 필요가 없다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>setState는 의존성 배열에서 필요가 없다.</h2>\n<p><code class=\"language-text\">useCallback</code>과 같은 메모이제이션 <code class=\"language-text\">hook</code>을 사용할 때 상태값 변경을 위한 <code class=\"language-text\">setState</code>를 의존성배열에 추가하는 경우가 있었는데, <code class=\"language-text\">setState</code>자체로는 <code class=\"language-text\">rerender</code>에 아무런 영향을 미치지 않기 때문에 추가할 필요가 없다고 한다.</p>\n<blockquote>\n<p>실제로 추가하지 않아도, <code class=\"language-text\">eslint</code>에서 아무런 에러를 발생시키지 않는다.</p>\n</blockquote>\n<h2 id=\"이벤트-핸들러-내에서-비동기적으로-작동되는-setstate\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC-%EB%82%B4%EC%97%90%EC%84%9C-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%9E%91%EB%8F%99%EB%90%98%EB%8A%94-setstate\" aria-label=\"이벤트 핸들러 내에서 비동기적으로 작동되는 setstate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이벤트 핸들러 내에서 비동기적으로 작동되는 setState</h2>\n<p>이벤트 핸들러 내에서 <code class=\"language-text\">setState</code>는 비동기 방식으로 작동된다고 한다.</p>\n<p>동일한 이벤트 호출을 통해 내부에서 여러번의 <code class=\"language-text\">setState</code>가 호출된다면, 모든 변화를 하나로 합쳐서 호출된 이벤트 핸들러가 종료될 때 단 한번만 <code class=\"language-text\">state</code>에 직접적인 변화가 일어난다.</p>\n<p><code class=\"language-text\">class</code>기반의 <code class=\"language-text\">setState</code>는 이를 동일한 <code class=\"language-text\">key</code>에대해 병합이 이뤄졌고\n<code class=\"language-text\">hook</code> 기반의 <code class=\"language-text\">setState</code>는 병합이 아니라 대체의 개념을 갖고있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>위처럼 두번 호출하여 원하는 결과가 <code class=\"language-text\">2</code>일것 같은 방법도 병합 혹은 대체의 과정을 통해 <code class=\"language-text\">1</code>의 결과를 반환한다.</p>\n<h2 id=\"함수형-setstate\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98%ED%98%95-setstate\" aria-label=\"함수형 setstate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수형 setState</h2>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">oldState</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>oldState<span class=\"token punctuation\">,</span> newVal<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">setState</code>에 콜백함수를 사용하여 상태값을 업데이트할 수 있다.</p>\n<p>이전의 상태값에대한 정보를 조회할 수 있으며, 이를 바탕으로 업데이트 하여 대체할 수 있다.</p>\n<p>이 특징에 있어서는 이전에 다뤘던 <code class=\"language-text\">useCallback</code>을 통한 메모이제이션과도 큰 관련이 있을것 같다.</p>\n<p>만약, 객체로된 상태값을 <code class=\"language-text\">useCallback</code>의 의존배열에 추가하여 메소드를 생성하고있을 경우, <code class=\"language-text\">setState</code>로 객체에 변경이 있을 때 계속해서 메소드를 재생산하게될 것이다.</p>\n<p>하지만, <code class=\"language-text\">setState</code>는 의존성 배열에 추가될 필요가 없다는 특징을 이용해보았을 때 처음에만 메소드를 생성하고, 이후에는 캐싱된 메소드로만 사용 가능할것 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> func <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">state</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>states<span class=\"token punctuation\">,</span> state <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>states<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> func <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">state</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">oldState</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>oldState<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2 id=\"단일-state-state-분리\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%9D%BC-state-state-%EB%B6%84%EB%A6%AC\" aria-label=\"단일 state state 분리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단일 state? state 분리?</h2>\n<p><code class=\"language-text\">useState</code>를 사용하여 상태값을 관리하고자 할 때, 선택할 수 있는 방법이 두가지 있다.</p>\n<p>여러 속성을 하나의 <code class=\"language-text\">useState</code>로 묶어서 사용할 것인가?</p>\n<p>속성들을 분리하여 각각의 <code class=\"language-text\">useState</code>를 통해 생성할 것인가?</p>\n<h3 id=\"분리-state\" style=\"position:relative;\"><a href=\"#%EB%B6%84%EB%A6%AC-state\" aria-label=\"분리 state permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>분리 state</h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>position<span class=\"token punctuation\">,</span> setPosition<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> x<span class=\"token operator\">:</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token number\">50</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>size<span class=\"token punctuation\">,</span> setSize<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> width<span class=\"token operator\">:</span> <span class=\"token number\">500</span><span class=\"token punctuation\">,</span> height<span class=\"token operator\">:</span> <span class=\"token number\">30</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>상태값을 분리하여 생성하게 될 경우, 상태값을 대체하는데에 비교적 편리할 수 있다.</p>\n<p>사실 가장 큰 이점으로 볼 수 있는 점은, 각각의 <code class=\"language-text\">hook</code>들을 커스텀 훅으로 분리하여 사용할 수 있다는 점이다.</p>\n<blockquote>\n<p>추상화에 큰 도움이 된다.</p>\n</blockquote>\n<h3 id=\"단일-state\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%9D%BC-state\" aria-label=\"단일 state permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단일 state</h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>state<span class=\"token punctuation\">,</span> setState<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> x<span class=\"token operator\">:</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> width<span class=\"token operator\">:</span> <span class=\"token number\">500</span><span class=\"token punctuation\">,</span> height<span class=\"token operator\">:</span> <span class=\"token number\">300</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">x</code>의 값을 변경하는데에 <code class=\"language-text\">width</code>라는 속성이 필요해서 하나의 <code class=\"language-text\">state</code>로 합쳐서 생성하였다. 서로간 연관되어있는 속성들끼리 함께 묶어서 생성하여 업데이트할 때 참조하는데에 편리함이 있다.</p>\n<p>나쁜방법은 아니지만, <code class=\"language-text\">useState.setState</code>는 대체라는 특징으로 인해 꼭 필요한 과정이 추가된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">oldState</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>oldState<span class=\"token punctuation\">,</span> x <span class=\"token operator\">:</span> <span class=\"token number\">700</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>늘 상태값이 대체되기 때문에, 일부분을 변경하게 된다면 이전 값에 대한 복제의 작업이 필요하다.</p>\n<h2 id=\"여러-상태값에-대한-참조-이전-상태값의-필요-메모이제이션-의존성-문제\" style=\"position:relative;\"><a href=\"#%EC%97%AC%EB%9F%AC-%EC%83%81%ED%83%9C%EA%B0%92%EC%97%90-%EB%8C%80%ED%95%9C-%EC%B0%B8%EC%A1%B0-%EC%9D%B4%EC%A0%84-%EC%83%81%ED%83%9C%EA%B0%92%EC%9D%98-%ED%95%84%EC%9A%94-%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98-%EC%9D%98%EC%A1%B4%EC%84%B1-%EB%AC%B8%EC%A0%9C\" aria-label=\"여러 상태값에 대한 참조 이전 상태값의 필요 메모이제이션 의존성 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>여러 상태값에 대한 참조, 이전 상태값의 필요, 메모이제이션 의존성 문제</h2>\n<p>웬만한 상황에서는 <code class=\"language-text\">useState</code>를 사용하여 상태값을 구성할 때 하나의 단일 보다는 구분하여 생성하는것이 더 효율적이다.</p>\n<p>하지만 예외적인 상황이 있다.</p>\n<ol>\n<li>상태값을 업데이트하는데 다른 상태값을 참조해야한다.</li>\n</ol>\n<p>이 문제에 있어서는 <code class=\"language-text\">useEffect</code>, 혹은 메모이제이션을 위한 <code class=\"language-text\">useCallback</code>을 사용할 때 더 크게 필요를 느끼게된다.</p>\n<p>자신의 상태값이 자주 변동되어서 <code class=\"language-text\">setState</code> 를 함수형식으로 전달하여 내부의 이전 <code class=\"language-text\">state</code>값을 참조하여 생성을 할 수 있어서 <code class=\"language-text\">useCallback</code>, <code class=\"language-text\">useEffect</code>들의 의존성배열을 비워 재생산, 재실행 되는것을 막을 수 있다고 위에서 설명했었다.</p>\n<p>하지만, <code class=\"language-text\">state</code>분리를 통해 각각의 상태가 서로를 참조할 수 있는 방법이 의존성배열밖에 없는 상황이라면?</p>\n<p>이것을 어쩔수 없는 재생산, 재실행이라고 보는것이 맞을까?</p>\n<p>그 비용이 어마어마해진다면 어떨까?</p>\n<h2 id=\"redux\" style=\"position:relative;\"><a href=\"#redux\" aria-label=\"redux permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redux</h2>\n<p>위 문제를 보았을 때 생각나는것이 있다.</p>\n<p><code class=\"language-text\">Redux</code></p>\n<ol>\n<li>중앙상태관리를 통해 다른 상태를 참조하여 상태값을 업데이트하는 로직을 생성할 수 있다.</li>\n<li>상태값을 업데이트 할 때, 이전의 상태값을 기반으로 업데이트 할 수 있다.</li>\n<li><code class=\"language-text\">Redux</code>의 <code class=\"language-text\">Dispatch</code>또한 마찬가지로 <code class=\"language-text\">rerender</code> 에는 영향을 주지 않기 때문에 <code class=\"language-text\">useEffect</code>, <code class=\"language-text\">useCallback</code>의 의존성 배열에 추가될 필요가 없다.</li>\n</ol>\n<p>알게모르게 <code class=\"language-text\">Redux</code>가 많은 고민을 해주고 있었다.</p>\n<p>하지만 늘 느껴왔지만, <code class=\"language-text\">Redux</code>를 사용하기위해서는 많은 셋팅이 필요하다.</p>\n<p>이러한 특징때문에 <code class=\"language-text\">Redux</code>를 개발한 개발자들도 <code class=\"language-text\">Redux</code>를 사용하는데 적합성을 판단하는것이 중요하다고 하더라.</p>\n<h2 id=\"usereducer\" style=\"position:relative;\"><a href=\"#usereducer\" aria-label=\"usereducer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useReducer</h2>\n<p><code class=\"language-text\">useReducer hook</code>을 사용하여 비교적 편리하게 <code class=\"language-text\">Redux</code>의 장점을 가져올 수 있었다.</p>\n<p>아마 <code class=\"language-text\">Redux</code>를 사용해보았다면, 빠르게 이해하고 적용해볼 수 있을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> initialState <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> count<span class=\"token operator\">:</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">reducer</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">state<span class=\"token punctuation\">,</span> action</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'increment'</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> count<span class=\"token operator\">:</span> state<span class=\"token punctuation\">.</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'decrement'</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> count<span class=\"token operator\">:</span> state<span class=\"token punctuation\">.</span>count <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">Counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>state<span class=\"token punctuation\">,</span> dispatch<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useReducer</span><span class=\"token punctuation\">(</span>reducer<span class=\"token punctuation\">,</span> initialState<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> handleDecrese <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'decrement'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> handleIncrease <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'increment'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">></span>\n      Count<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>state<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">}</span>\n      <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>handleDecrese<span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">-</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>handleIncrease<span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">+</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">React</code> 공식문서에서 설명되어있는 예제를 살짝 수정해보았다.</p>\n<ol>\n<li><code class=\"language-text\">dispatch</code>메소드는 <code class=\"language-text\">rerender</code>에 아무런 영향을 주지 않기 때문에, 의존성 목록에 추가해줄 필요가 없다.</li>\n<li>이전의 상태값에 대한 정보를 사용하고 반영할 수 있다.</li>\n<li>\n<p>다른 상태값에 대한 참조가 필요한 경우, 공통된 <code class=\"language-text\">state</code>에서 찾아 사용할 수 있다.</p>\n<blockquote>\n<p>특히나, 기존에 <code class=\"language-text\">useEffect</code>, <code class=\"language-text\">useCallback</code>등이 의존하고 있는 상태값의 변화가 잦을 수록 좋다.</p>\n</blockquote>\n</li>\n<li>상태값을 업데이트하는 로직의 규모가 커질수록 구분하여 관리하기 좋다.</li>\n<li><code class=\"language-text\">setState</code>가 아닌 별도의 <code class=\"language-text\">action</code>으로 구분하여 호출하기 때문에, 여러개의 상태값에 대한 업데이트가 용이하다.</li>\n</ol>\n<p>공식문서에서 설명된 특징들과 경험해본 느낌을 간추려본 장점들이다.</p>\n<p>대부분의 상황에서는 <code class=\"language-text\">useState</code>와 <code class=\"language-text\">custom hook</code>이 좋아보이지만, 위와같은 상황일 경우에는 <code class=\"language-text\">useReducer</code>가 더 적합할 수 있을것 같다.</p>\n<p>특히, 이전에 진행했던 <code class=\"language-text\">socket.io</code>를 통한 실시간채팅과같이 짧은 순간순간에 <code class=\"language-text\">setState</code>가 여러번 발생하여 의존성배열 변경으로 인해 메모이제이션의 의미가 많이 퇴색되는 상황에서는 더 빛을 볼 것 같다.</p>\n<h2 id=\"참조\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EC%A1%B0\" aria-label=\"참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참조</h2>\n<ul>\n<li><a href=\"https://ko.reactjs.org/docs/hooks-state.html\">React State hook</a></li>\n<li><a href=\"https://ko.reactjs.org/docs/hooks-faq.html#should-i-use-one-or-many-state-variables\">React 하나 또는 여러 state 변수 사용?</a></li>\n<li><a href=\"https://ko.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often\">React 종속성이 자주 변경되는 상황</a></li>\n<li><a href=\"https://ko.reactjs.org/docs/hooks-reference.html#additional-hooks\">React additional hook</a></li>\n<li><a href=\"https://adamrackis.dev/state-and-use-reducer/\">hook, state, reducer</a></li>\n</ul>","frontmatter":{"title":"⚛ useState, Redux 그리고 useReducer","date":"September 01, 2021"}}},"pageContext":{"slug":"/Study/Think/useState,redux,useReducer/","previous":{"fields":{"slug":"/Study/Think/memohooks/"},"frontmatter":{"title":"⚛ 메모이제이션 hooks의 오용","category":"Study","draft":false,"tag":"Think"}},"next":null}},"staticQueryHashes":["3128451518","3665928227","479399088","479399088"]}