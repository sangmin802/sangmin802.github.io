{"componentChunkName":"component---src-templates-blog-post-js","path":"/Study/Think/2021-01-26-next.js hydrate/","result":{"data":{"site":{"siteMetadata":{"title":"SangMin 개발 이야기","author":"SangMin","siteUrl":"https://gatsby-starter-bee.netlify.com","comment":{"disqusShortName":"","utterances":"JaeYeopHan/gatsby-starter-bee"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"8ea12678-d400-5c3c-b2cb-46461c830bc7","excerpt":"예전에 CSR과 SSR을 비교해보면서 React도 SSR이 가능하도록 할 수 있는지 알아보는 과정에 hydrate메소드를 발견했었다. 그리고, Next.js를 학습하던 도중, 해당 용어를 다시 만나게 되었다. Before we talk about data fetching, let’s talk about one of the most important concepts in Next.js: Pre-rendering. By default, Next.js pre-renders every page. This…","html":"<p>예전에 CSR과 SSR을 비교해보면서 React도 SSR이 가능하도록 할 수 있는지 알아보는 과정에 hydrate메소드를 발견했었다.</p>\n<p>그리고, Next.js를 학습하던 도중, 해당 용어를 다시 만나게 되었다.</p>\n<blockquote>\n<p>Before we talk about data fetching, let’s talk about one of the most important concepts in Next.js: Pre-rendering.</p>\n</blockquote>\n<blockquote>\n<p>By default, Next.js pre-renders every page. This means that Next.js generates HTML for each page in advance, instead of having it all done by client-side JavaScript. Pre-rendering can result in better performance and SEO.</p>\n</blockquote>\n<blockquote>\n<p>Each generated HTML is associated with minimal JavaScript code necessary for that page. When a page is loaded by the browser, its JavaScript code runs and makes the page fully interactive. (This process is called <strong>hydration</strong>.)</p>\n</blockquote>\n<p>Next.js는 Pre-rendering 기능을 통해 각각의 페이지들의 돔을 미리 구성하기 때문에, 검색엔진에 최적화되어있으며 해당 페이지가 클라이언트사이드에서 실행되었을 때, 스크립트 코드가 읽히며 상호작용이 가능해진다는 점이다.</p>\n<p>예전에 봤던 hydrate메소드의 역활과 동일하다.</p>\n<h2 id=\"pre-rendering\" style=\"position:relative;\"><a href=\"#pre-rendering\" aria-label=\"pre rendering permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pre-rendering</h2>\n<p>Next.js의 가장 큰 특징이 Pre-rendering을 한다는 점이다.</p>\n<ul>\n<li>\n<p>Next.js / Pre-rendering</p>\n<div style=\"margin : 0 auto; text-align : center\">\n<img src=\"https://nextjs.org/static/images/learn/data-fetching/pre-rendering.png\" alt=\"prerender\">\n</div>\n</li>\n<li>\n<p>React.js / No Pre-rendering</p>\n<div style=\"margin : 0 auto; text-align : center\">\n<img src=\"https://nextjs.org/static/images/learn/data-fetching/no-pre-rendering.png\" alt=\"prerender\">\n</div>\n</li>\n</ul>\n<h2 id=\"static-generation-vs-server-side-rendering\" style=\"position:relative;\"><a href=\"#static-generation-vs-server-side-rendering\" aria-label=\"static generation vs server side rendering permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Static Generation vs Server-side Rendering</h2>\n<ul>\n<li>\n<p>정적 생성</p>\n<ul>\n<li>Pre-rendering 메소드가 빌드가 될 때 HTML을 구성한다. 이후, 각 요청에는 생성됬던 HTML들이 재사용된다.</li>\n</ul>\n</li>\n</ul>\n<div style=\"margin : 0 auto; text-align : center\">\n  <img src=\"https://nextjs.org/static/images/learn/data-fetching/static-generation.png\" alt=\"static generation\">\n</div>\n<ul>\n<li>\n<p>서버측 렌더링</p>\n<ul>\n<li>요청이 있을때마다 HTML을 구성한다.</li>\n</ul>\n</li>\n</ul>\n<div style=\"margin : 0 auto; text-align : center\">\n  <img src=\"https://nextjs.org/static/images/learn/data-fetching/server-side-rendering.png\" alt=\"server-side rendering\">\n</div>\n<h2 id=\"선택적-pre-rendering\" style=\"position:relative;\"><a href=\"#%EC%84%A0%ED%83%9D%EC%A0%81-pre-rendering\" aria-label=\"선택적 pre rendering permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>선택적 Pre-rendering</h2>\n<p>Next.js의 중요한 점은 각각의 페이지들이 어떤 Pre-rendering방식을 사용할 것인지 선택할 수 있다는 점이다.</p>\n<div style=\"margin : 0 auto; text-align : center\">\n  <img src=\"https://nextjs.org/static/images/learn/data-fetching/per-page-basis.png\" alt=\"Per-page Basis\">\n</div>\n<h2 id=\"두개의-pre-rendering-어떤-상황에-사용\" style=\"position:relative;\"><a href=\"#%EB%91%90%EA%B0%9C%EC%9D%98-pre-rendering-%EC%96%B4%EB%96%A4-%EC%83%81%ED%99%A9%EC%97%90-%EC%82%AC%EC%9A%A9\" aria-label=\"두개의 pre rendering 어떤 상황에 사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>두개의 Pre-rendering 어떤 상황에 사용?</h2>\n<p><code class=\"language-text\">사용자의 요청이 없어도 페이지를 렌더링 할 수 있습니까?</code>라고 자문했을 때, <code class=\"language-text\">네</code> 라면 정적 생성, <code class=\"language-text\">아니오</code> 라면 서버측 렌더링을 사용해야한다.</p>\n<h2 id=\"static-generation---getstaticprops\" style=\"position:relative;\"><a href=\"#static-generation---getstaticprops\" aria-label=\"static generation   getstaticprops permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Static Generation - getStaticProps</h2>\n<p>대부분의 웹앱은 첫 페이지에서 데이터를 가공하여 보여주는경우가 많다.</p>\n<p>이런 경우에도 정적생성이 적합하다.</p>\n<div style=\"margin : 0 auto; text-align : center\">\n  <img src=\"https://nextjs.org/static/images/learn/data-fetching/static-generation-with-data.png\" alt=\"static generation with data\">\n</div>\n<p>페이지 컴포넌트를 내보낼 때, <code class=\"language-text\">getStaticProps</code> 메소드를 반환하는 <code class=\"language-text\">async</code>비동기 함수를 함께 내보낼 수 있다.</p>\n<ul>\n<li><code class=\"language-text\">getStaticProps</code>메소드는 빌드될 때 실행이 되며</li>\n<li>함수 내부에서 http작업을 통해 데이터를 받아오고 해당 페이지의 속성으로 보내준다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Home</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getStaticProps</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Get external data from the file system, API, DB, etc.</span>\n  <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token operator\">...</span>\n\n  <span class=\"token comment\">// The value of the `props` key will be</span>\n  <span class=\"token comment\">//  passed to the `Home` component</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    props<span class=\"token operator\">:</span> <span class=\"token operator\">...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>해당 메소드를 사용하여, 외부 Fetch등의 메소드로 외부 API도 가져올 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getSortedPostsData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Instead of the file system,</span>\n  <span class=\"token comment\">// fetch post data from an external API endpoint</span>\n  <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'..'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>해당메소드로 외부 API를 가져오는 작업을 수행해보았는데, 기존에 연결해놓은 프록시서버가 없어도 잘 작동된다.</p>\n<p>아마 서버측에서 작동되는 <code class=\"language-text\">getStaticProps</code>메소드이기 때문에, 해당 서버가 프록시서버 역활을 하는게 아닌가 싶다.</p>\n<h3 id=\"somedatabasesdk\" style=\"position:relative;\"><a href=\"#somedatabasesdk\" aria-label=\"somedatabasesdk permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>someDatabaseSDK</h3>\n<p>심지어 바로 DB쿼리를 입력할 수도 있다고 함..</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> someDatabaseSDK <span class=\"token keyword\">from</span> <span class=\"token string\">'someDatabaseSDK'</span>\n\n<span class=\"token keyword\">const</span> databaseClient <span class=\"token operator\">=</span> someDatabaseSDK<span class=\"token punctuation\">.</span><span class=\"token function\">createClient</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getSortedPostsData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Instead of the file system,</span>\n  <span class=\"token comment\">// fetch post data from a database</span>\n  <span class=\"token keyword\">return</span> databaseClient<span class=\"token punctuation\">.</span><span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token string\">'SELECT posts...'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이와같이 사용할 수 있는 이유는, <code class=\"language-text\">getStaticProps</code>가 서버측에서 실행되기 떄문이라고 한다.</p>\n<p>배포할 때에는 빌드될 때만 실행되기 때문에, 사용자의 요청일 경우(즉, 쿼리변수나 헤더가 있는 http요청)에는 사용하지 않는것이 좋다</p>\n<blockquote>\n<p>위의 경우에는 정적생성이 아닌 서버측 렌더링을 사용하는것</p>\n</blockquote>\n<h2 id=\"server-side-rendering\" style=\"position:relative;\"><a href=\"#server-side-rendering\" aria-label=\"server side rendering permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Server-side Rendering</h2>\n<p>사용자의 요청이 있어서 쿼리 변수등이 있고, 요청에 따라 각기 다른 새로운 데이터를 받아와야 한다면 서버측 렌더링을 사용해야한다.</p>\n<div style=\"margin : 0 auto; text-align : center\">\n  <img src=\"https://nextjs.org/static/images/learn/data-fetching/server-side-rendering-with-data.png\" alt=\"server-side-rendering-with-data\">\n</div>\n<h2 id=\"server-side-rendering---getserversideprops\" style=\"position:relative;\"><a href=\"#server-side-rendering---getserversideprops\" aria-label=\"server side rendering   getserversideprops permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Server-side Rendering - getServerSideProps</h2>\n<p>정적생성에는 <code class=\"language-text\">getStaticProps</code>메소드를 사용했다면, 서버측 렌더링에는 <code class=\"language-text\">getServerSideProps</code>메소드를 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getServerSideProps</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// props for your component</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>해당 메소드는 요청할 때, 실행이 되며 <code class=\"language-text\">context</code>는 <code class=\"language-text\">params</code>, <code class=\"language-text\">req</code>, <code class=\"language-text\">res</code>, <code class=\"language-text\">qauery</code>등의 속성들을 갖고있는 변수이다.</p>\n<p>또한, 매 요청마다 서버측에서 작업을 하기 때문에, 정적생성보다 비교적 느리며 캐싱되지 않는다.</p>\n<h2 id=\"client-side-rendering\" style=\"position:relative;\"><a href=\"#client-side-rendering\" aria-label=\"client side rendering permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Client-side Rendering</h2>\n<p>만약, 페이지를 보여주는데 데이터를 꼭 받아올 필요가 없다면, React.js의 방식처럼 클라이언트단에서 데이터를 받아오게 할 수 있다.</p>\n<div style=\"margin : 0 auto; text-align : center\">\n  <img src=\"https://nextjs.org/static/images/learn/data-fetching/client-side-rendering.png\" alt=\"Client-side Rendering\">\n</div>\n<p>생각해보면, 모든 페이지가 검색엔진에 노출될 필요가 없이 첫 화면만 노출이 필요하다면, index페이지만 정적생성을 통해 Pre-rendering을 하고, 이후는 클라이언트단 렌더링을 사용해도 될 것 같다.</p>\n<blockquote>\n<p>아직 프로젝트에 적용해보지 않아 헛소리일 수도 있지만, 정말 Next.js에서 말한대로 <code class=\"language-text\">Server-side Rendering</code>을 사용하는일은 거의 없을것 같은데..?</p>\n</blockquote>\n<h2 id=\"swr\" style=\"position:relative;\"><a href=\"#swr\" aria-label=\"swr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SWR</h2>\n<p>데이터를 클라이언트단에서 가져와도 된다면, Next.js에서는 SWR이라는 기능을 제공한다.</p>\n<p>React Hook의 일종으로 클라이언트측에서 데이터를 받아올 때 캐싱, 재검증등을 제공하는 기능을 갖고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> useSWR <span class=\"token keyword\">from</span> <span class=\"token string\">'swr'</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">Profile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> data<span class=\"token punctuation\">,</span> error <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useSWR</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/user'</span><span class=\"token punctuation\">,</span> fetch<span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>failed to load<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>data<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>loading<span class=\"token operator\">...</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>hello <span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">!</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<ul>\n<li><a href=\"https://vercel.com/blog/nextjs-server-side-rendering-vs-static-generation\">서버측 렌더링 vs 정적 생성 사용상황 예제</a></li>\n<li><a href=\"https://nextjs.org/learn/basics/data-fetching\">Next.js Pre-rendering</a></li>\n</ul>","frontmatter":{"title":"Next.js Pre-rendering","date":"January 26, 2021"}}},"pageContext":{"slug":"/Study/Think/2021-01-26-next.js hydrate/","previous":{"fields":{"slug":"/Study/DataStructure/2021-01-25-programmers_05_sort/"},"frontmatter":{"title":"프로그래머스-H-Index","category":"Study","draft":false,"tag":"Programmers Coding Test"}},"next":{"fields":{"slug":"/Study/DataStructure/2021-01-27-programmers_06_full exploration/"},"frontmatter":{"title":"프로그래머스-모의고사","category":"Study","draft":false,"tag":"Programmers Coding Test"}}}},"staticQueryHashes":["3128451518","3665928227"]}