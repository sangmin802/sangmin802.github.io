{"componentChunkName":"component---src-templates-blog-post-js","path":"/Study/Think/prototype/","result":{"data":{"site":{"siteMetadata":{"title":"SangMin 개발 이야기","author":"SangMin","siteUrl":"https://sangmin802.github.io","comment":{"disqusShortName":"","utterances":"sangmin802/sangmin802.github.io"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"2882f366-d373-5796-b343-98e40ccfcb0b","excerpt":"에서 라는 문법이 도입되고, 상속을 통해 사용하고있는 객체를 확장하는등의 작업을 할 수 있다. 의 기반 컴포넌트들도 비슷한 원리일 것이다. 그렇다면, 기존의 자바스크립트에서 업데이트되면서 문법이 추가되었다는 것인데, 이전의 자바스크립트에서는 객체간 상속이란것이 불가능하였을 까? Javascript 상속의 뿌리 prototype…","html":"<p><code class=\"language-text\">ECMAScript 2015</code>에서 <code class=\"language-text\">class</code>라는 문법이 도입되고, 상속을 통해 사용하고있는 객체를 확장하는등의 작업을 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> 확장객체 <span class=\"token keyword\">extends</span> 루트객체 <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">React</code>의 <code class=\"language-text\">class</code>기반 컴포넌트들도 비슷한 원리일 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">CustomComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>그렇다면, 기존의 자바스크립트에서 업데이트되면서 <code class=\"language-text\">class</code>문법이 추가되었다는 것인데, 이전의 자바스크립트에서는 객체간 상속이란것이 불가능하였을 까?</p>\n<h2 id=\"javascript-상속의-뿌리-prototype\" style=\"position:relative;\"><a href=\"#javascript-%EC%83%81%EC%86%8D%EC%9D%98-%EB%BF%8C%EB%A6%AC-prototype\" aria-label=\"javascript 상속의 뿌리 prototype permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Javascript 상속의 뿌리 prototype</h2>\n<p><code class=\"language-text\">Javascript</code>는 흔히 프로토타입 기반 언어라고 한다. 추가된 <code class=\"language-text\">Javascript</code>의 <code class=\"language-text\">class</code> 문법 또한 사실, 프로토타입 기반이라고 한다.</p>\n<p><code class=\"language-text\">Javascript</code>내의 모든 객체들은 메소드를 포함한 속성들을 상속받기 위해서 <strong>프로토타입 객체(prototype object)</strong>라는것을 갖는다고 한다.</p>\n<blockquote>\n<p>상속되는 속성들은 해당 객체의 속성으로 바로 존재하는것이 아닌, 객체의 생성자의 <code class=\"language-text\">prototype</code>이라는 속성에 정의 됨</p>\n</blockquote>\n<p>해당 객체를 통해, 상위 혹은 그보다 더 상위 객체로부터 속성들을 상속받을 수 있다고 한다.</p>\n<p>이렇게 <code class=\"language-text\">프로토타입 객체</code>를 통해 속성들을 상속받는 줄기를 <strong>프로토타입 체인(prototype chain)</strong>이라고 한다.</p>\n<h3 id=\"프로토타입-객체와-프로토타입-체인\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EA%B0%9D%EC%B2%B4%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8\" aria-label=\"프로토타입 객체와 프로토타입 체인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로토타입 객체와 프로토타입 체인</h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name<span class=\"token punctuation\">,</span> age</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> me <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'상민'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">27</span><span class=\"token punctuation\">)</span>\nme<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">Person</code>이라는 생성자 함수로 <code class=\"language-text\">me</code>라는 객체를 만들고, <code class=\"language-text\">valueOf</code>라는 메소드를 호출을 시켜보았다.</p>\n<p>사실, <code class=\"language-text\">valueOf</code>라는 메소드는 <code class=\"language-text\">object</code>의 메소드이다. 따라서, 해당 메소드를 갖고있는 <code class=\"language-text\">me</code>객체는 존재하지 않는다는 에러를 반환해야된다고 생각하지만, 정상적으로 호출이 된다.</p>\n<p>왜일까?</p>\n<div style=\"margin : 0 auto; text-align : center\">\n  <img src=\"/img/2021/07/25/1.PNG\" alt=\"1\">\n</div>\n<ol>\n<li><code class=\"language-text\">me</code>라는 객체에서 <code class=\"language-text\">valueOf</code>라는 속성으 탐색한다.</li>\n<li>\n<p>해당 속성이 존재하지 않아, <code class=\"language-text\">me</code>는 <strong>프로토타입 체인</strong>으로 연결된 <strong>프로토타입 객체</strong>에서 <code class=\"language-text\">valueOf</code>라는 속성을 탐색한다.</p>\n<blockquote>\n<p>이 때의 <strong>프로토타입 객체</strong>에는 <code class=\"language-text\">Person</code>생성자 함수가 존재함</p>\n</blockquote>\n</li>\n<li>\n<p>마찬가지로 해당 <strong>프로토타입 객체</strong> 에도 존재하지 않아, 해당 <strong>프로토타입 객체</strong>의 <strong>프로토타입 체인</strong>으로 연결된 <strong>프로토타입 객체</strong>를 탐색함</p>\n<blockquote>\n<p>이 때의 <strong>프로토타입 객체</strong>에는 <code class=\"language-text\">Object</code>객체가 존재함</p>\n</blockquote>\n</li>\n<li><code class=\"language-text\">Object</code>에서 <code class=\"language-text\">valueOf</code>라는 메소드를 발견하고, 호출함</li>\n</ol>\n<h2 id=\"프로토타입-체인---prototype-chain\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8---prototype-chain\" aria-label=\"프로토타입 체인   prototype chain permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로토타입 체인 - prototype chain</h2>\n<p>모든 객체들이 갖고있는 하나의 공통된 속성이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span></code></pre></div>\n<div style=\"margin : 0 auto; text-align : center\">\n  <img src=\"/img/2021/07/25/2.PNG\" alt=\"2\">\n</div>\n<p><code class=\"language-text\">[[Prototype]]</code>라는 숨겨진 속성이다. 이 객체를 통해 참조할수 있는 다른 객체를 설명한다. 이러한 방식으로 참조할 수 있는 객체들이 <code class=\"language-text\">[[Prototype]]</code>이라는 숨겨진 속성으로 연결되어있는 것을 <strong>프로토타입 체인</strong> 이라고 한다.</p>\n<p>위에서, <code class=\"language-text\">valueOf</code>라는 속성을 찾아갈 때 생성자 함수로 생성된 함수 또한 객체이므로 <code class=\"language-text\">[[Prototype]]</code> 숨김 속성을 갖고 있었고, 그 <strong>프로토타입 체인</strong>을 통해 상속하고있는 <strong>프로토타입 객체</strong>를 타고 가다, <code class=\"language-text\">Object</code>에서 해당 메소드를 발견한 것이다.</p>\n<p>만약, 가장 끝의 프로토타입 객체에도 존재하지 않았다면 <code class=\"language-text\">undefined</code>를 반환하게 된다.</p>\n<h2 id=\"함수의-prototype\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98%EC%9D%98-prototype\" aria-label=\"함수의 prototype permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수의 prototype</h2>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name<span class=\"token punctuation\">,</span> age</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>type <span class=\"token operator\">=</span> <span class=\"token string\">'person'</span>\n<span class=\"token keyword\">const</span> me <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'상민'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">27</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">dir</span><span class=\"token punctuation\">(</span>me<span class=\"token punctuation\">)</span></code></pre></div>\n<div style=\"margin : 0 auto; text-align : center\">\n  <img src=\"/img/2021/07/25/3.PNG\" alt=\"3\">\n</div>\n<p>생성자 함수를 사용하여 객체를 생성했다면, <code class=\"language-text\">prototype</code>속성을 사용하여 <strong>프로토타입 객체</strong>에 접근할 수 있다.</p>\n<p>하지만, <code class=\"language-text\">.prototype</code> 을 통한 방법으로는 모든 객체가 아닌 위와 같은 생성자 함수 에서만 접근이 가능하다.</p>\n<p>생성자함수에서의 <code class=\"language-text\">.prototype</code>은 이전의 모든 객체가 갖고있는 <code class=\"language-text\">[[Prototype]]</code>라는 숨겨진 속성을 통해 접근할 수 있는 참조 객체인 <code class=\"language-text\">prototype</code>과 이름이 유사해보이지만 사실은 다르다.</p>\n<blockquote>\n<p>생성자함수의 <code class=\"language-text\">.prototype</code>으로 접근하는 객체는 이름만 <code class=\"language-text\">prototype</code>인 일반 속성이다.</p>\n</blockquote>\n<p><code class=\"language-text\">생성자함수.prototype</code>는, 해당 생성자 함수를 통해 만들어지는 객체의 <code class=\"language-text\">[[Prototype]]</code>으로 연결되는 <code class=\"language-text\">prototype</code>객체의 값으로 사용하라는 뜻이다.</p>\n<div style=\"margin : 0 auto; text-align : center\">\n  <img src=\"/img/2021/07/25/5.PNG\" alt=\"5\">\n</div>\n<p>만약 <code class=\"language-text\">const obj = {}</code>와 같은 일반 객체에서 <code class=\"language-text\">prototype</code>속성에 접근하기 위해서는 <code class=\"language-text\">__proto__</code>를 사용해야 한다.</p>\n<blockquote>\n<p><code class=\"language-text\">setter</code>와 <code class=\"language-text\">getter</code> 역할을 수행</p>\n</blockquote>\n<p>이를 통해 알 수 있는점은, <code class=\"language-text\">__proto__</code>는 객체의 속성이 아닌, <code class=\"language-text\">prototype</code>에 접근하기 위한 속성일 뿐이다.</p>\n<div style=\"margin : 0 auto; text-align : center\">\n  <img src=\"/img/2021/07/25/4.png\" alt=\"4\">\n</div>\n<p>생성자 함수를 정의하였을 때 두가지 반응이 일어난다.</p>\n<ol>\n<li>기본 반응인 본인 자신이 정의됨</li>\n<li>\n<p>생성자 함수는 함수이기 때문에, <code class=\"language-text\">prototype</code>이라는 속성을 기본적으로 가지고 있다.</p>\n<blockquote>\n<p>이 속성에는 기본적으로 함수 자기 자신을 지칭하는 <code class=\"language-text\">counstructor</code>속성과, 자신을 통해 생성되는 객체의 <code class=\"language-text\">[[Prototype]]</code>으로 연결되는 <code class=\"language-text\">prototype</code> 객체를 지정해줄 수 있다.\n이때, <code class=\"language-text\">constructor</code>의 값을 유지하기 위해 <code class=\"language-text\">.prototype</code>을 아예 새로운 객체로 변경하기 보다는 속성을 추가해주는것이 좋다.</p>\n</blockquote>\n</li>\n</ol>\n<p>이렇게 정의된 생성자 함수로 생성된 객체는, 프로토타입 체인을 통해 자신을 생성한 생성자 함수의 프로토타입 객체에 접근할 수 있다.</p>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<p><code class=\"language-text\">Javascript</code>의 발전으로 <code class=\"language-text\">class</code>문법이 등장하긴 했지만, 이 또한 <code class=\"language-text\">prototype</code>기반의 문법이였다.</p>\n<p>모든 객체들의 <code class=\"language-text\">[[Prototype]]</code>라는 속성은, <code class=\"language-text\">prototype chain</code>을 의미하였고, 이 연결을 통해 참조되고있는 <code class=\"language-text\">prototype</code>객체들에 접근할 수 있었다.</p>\n<p>함수의 경우 정의될 때 추가적으로 함수의 <code class=\"language-text\">prototpye</code>속성이 자동으로 생성되었고, 이 속성의 내부에는 기본적으로 함수 자기자신을 지칭하는 <code class=\"language-text\">consturctor</code>가 존재하며, 다른 속성을 추가할 수 있었다.</p>\n<p>생성자 함수를 통해 생성되는 객체의 <code class=\"language-text\">[[Prototype]]</code>을 통해 연결되는 <code class=\"language-text\">prototype</code> 객체는 생성자 함수가 정의될 때 만들어진 <code class=\"language-text\">prototype object</code>였다.</p>\n<p><code class=\"language-text\">prototype object</code>들도 마찬가지로 <code class=\"language-text\">[[Prototype]]</code>속성을 통한 <code class=\"language-text\">prototype chain</code>이 있었고, 해당 <code class=\"language-text\">chaining</code>을 타고 올라가며 찾고자 하는 속성을 탐색한다.</p>\n<h2 id=\"추가참고\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EA%B0%80%EC%B0%B8%EA%B3%A0\" aria-label=\"추가참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추가참고</h2>\n<ul>\n<li><a href=\"https://evan-moon.github.io/2019/10/23/js-prototype/#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8\">js-prototype</a></li>\n</ul>","frontmatter":{"title":"🌳 자바스크립트 class의 뿌리 prototype","date":"July 23, 2021"}}},"pageContext":{"slug":"/Study/Think/prototype/","previous":{"fields":{"slug":"/Study/Think/this/"},"frontmatter":{"title":"🧙‍♀️ this를 제어하는 자","category":"Study","draft":false,"tag":"Think"}},"next":{"fields":{"slug":"/Study/Think/browser/"},"frontmatter":{"title":"💻 브라우저 렌더링의 시작","category":"Study","draft":false,"tag":"Think"}}}},"staticQueryHashes":["3128451518","3665928227","479399088","479399088"]}