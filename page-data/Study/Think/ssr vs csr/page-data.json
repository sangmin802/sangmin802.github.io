{"componentChunkName":"component---src-templates-blog-post-js","path":"/Study/Think/ssr vs csr/","result":{"data":{"site":{"siteMetadata":{"title":"SangMin 개발 이야기","author":"SangMin","siteUrl":"https://sangmin802.github.io","comment":{"disqusShortName":"","utterances":"sangmin802/sangmin802.github.io"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"9b1e839a-db77-5bce-bc12-f0e1e8ee506b","excerpt":"라는 동일한 웹앱을 와 순수  두가지 버전으로 제작을 해보았다. 우리가 흔히 을 채택하는 이유는 클라이언트의 입장에서 첫 화면을 빠르게 접할 수 있는점과, 각종 검색포털의 크롤러가 생성한 웹 사이트를 잘 긁어갈 수 있도록 일부분의 돔을 구성하고 있다는 점이였다. 실제로 눈으로 보는것이 더 좋을것 같아 결과물을 비교해보았다. TTV…","html":"<p><code class=\"language-text\">Loa-Hands</code>라는 동일한 웹앱을 <code class=\"language-text\">Next.js</code>와 순수 <code class=\"language-text\">React.js</code> 두가지 버전으로 제작을 해보았다.</p>\n<p>우리가 흔히 <code class=\"language-text\">SSR</code>을 채택하는 이유는 클라이언트의 입장에서 첫 화면을 빠르게 접할 수 있는점과, 각종 검색포털의 크롤러가 생성한 웹 사이트를 잘 긁어갈 수 있도록 일부분의 돔을 구성하고 있다는 점이였다.</p>\n<p>실제로 눈으로 보는것이 더 좋을것 같아 결과물을 비교해보았다.</p>\n<h2 id=\"ttv\" style=\"position:relative;\"><a href=\"#ttv\" aria-label=\"ttv permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TTV</h2>\n<div style=\"display : flex; justify-content : space-between;\">\n  <img style=\"display : inlneblock; width : 49%\" src=\"/img/2021/02/11/3.gif?raw=true\" alt=\"result1\">\n  <img style=\"display : inlneblock; width : 49%\" src=\"/img/2021/02/11/4.gif?raw=true\" alt=\"result2\">\n</div>\n<p>첫번째 이미지가 <code class=\"language-text\">Next.js</code>의 <code class=\"language-text\">SSR</code></p>\n<p>두번째 이미지가 순수 <code class=\"language-text\">React.js</code>로만 만든 <code class=\"language-text\">CSR</code>이다.</p>\n<p><strong><code class=\"language-text\">SSR</code></strong>의 경우, 그냥 <code class=\"language-text\">jpg</code> 이미지 같지만, 사실 서버에게 첫 요청부터 화면 생성까지의 <code class=\"language-text\">gif</code>이다. 즉, 클라이언트의 입장에서 봤을 때, 로딩이란것이 전혀느껴지지않는다.</p>\n<blockquote>\n<p>배포단계에서, 첫 화면은 서버에서 데이터를 모두 받아 돔을 생성하고 클라이언트에게 넘겨주기 때문!</p>\n</blockquote>\n<p><strong><code class=\"language-text\">CSR</code></strong>의 경우, 클라이언트가 서버에 첫 요청을 하고, 10초정도의 시간이 지난 후에 모든 화면이 완성된다. 클라이언트의 입장에서는 실로 어마어마한 로딩시간이라고 볼 수 있다.</p>\n<blockquote>\n<p>사실상 <code class=\"language-text\">cors</code>문제 때문에, 무료로 생성한 <code class=\"language-text\">proxy</code>서버를 한단계 거쳐서 가느라 더 오래걸리는 수도 있긴 함..</p>\n</blockquote>\n<blockquote>\n<p>서버에서 클라이언트에게 빈 <code class=\"language-text\">html</code>파일이 전달되면, 브라우저상에서 스크립트 파일을 읽어 일부분 화면을 구성하고, 외부 데이터를 사용하여 만드는 동적인 돔들의 경우 <code class=\"language-text\">http</code>통신을 위한 추가적인 시간이 필요하므로 이러한 결과가 발생한 것이다.</p>\n</blockquote>\n<h2 id=\"seo\" style=\"position:relative;\"><a href=\"#seo\" aria-label=\"seo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SEO</h2>\n<div style=\"display : flex; justify-content : space-between;\">\n  <img style=\"display : inlneblock; width : 49%\" src=\"/img/2021/02/11/1.PNG?raw=true\" alt=\"result3\">\n  <img style=\"display : inlneblock; width : 49%\" src=\"/img/2021/02/11/2.PNG?raw=true\" alt=\"result4\">\n</div>\n<p><strong><code class=\"language-text\">SSR</code></strong>의 경우 빌드 시, 외부 데이터를 받아와서 생성하는 동적인 부분도 모두 서버에서 처리 후, <code class=\"language-text\">index.html</code>을 반환하기 때문에 채워저있는 <code class=\"language-text\">index.html</code>을 확인할 수 있다.</p>\n<p>당연하게도, 이렇다보니 검색엔진들은 해당 돔들을 크롤링하여 각 포털사이트에 노출이 될 수 있는것이다.</p>\n<p><strong><code class=\"language-text\">CSR</code></strong>의 경우, 초기에 비어있는 <code class=\"language-text\">index.html</code>을 반환하기 때문에 검색엔진들은 해당 웹사이트에대한 정보를 크롤링 하지 못하여 흔히말하는 <code class=\"language-text\">컨텐츠부족</code>이라는 문제를 발생시키고 포털사이트에 노출이 되지 않는다.</p>\n<p>실제로 두가지 방법을 통해 같은 웹앱을 만들어보았는데, 눈에띄게 차이가 있어 어느정도 확신을 갖게되었다.</p>\n<p>물론 <code class=\"language-text\">Next.js</code>를 사용한 웹앱은 첫 화면만 <code class=\"language-text\">SSR</code>로 구성하였고, 이후 검색 라우트(페이지)등, 다른것들은 <code class=\"language-text\">CSR</code>형식을 취하고 있어 두가지 렌더링 방식을 모두 보유하고있다.</p>\n<p>😃앞으로 <code class=\"language-text\">Next.js</code>를 더 애용하게될 듯 하다..</p>","frontmatter":{"title":"SSR vs CSR 비교","date":"February 11, 2021"}}},"pageContext":{"slug":"/Study/Think/ssr vs csr/","previous":{"fields":{"slug":"/Study/Think/Redux-Saga/"},"frontmatter":{"title":"Redux-Saga","category":"Study","draft":false,"tag":"Think"}},"next":{"fields":{"slug":"/Study/Think/mvc&&flux/"},"frontmatter":{"title":"MVC && Flux","category":"Study","draft":false,"tag":"Think"}}}},"staticQueryHashes":["3128451518","3665928227","479399088","479399088"]}