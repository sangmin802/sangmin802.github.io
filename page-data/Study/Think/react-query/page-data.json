{"componentChunkName":"component---src-templates-blog-post-js","path":"/Study/Think/react-query/","result":{"data":{"site":{"siteMetadata":{"title":"SangMin 개발 이야기","author":"SangMin","siteUrl":"https://sangmin802.github.io","comment":{"utterances":"sangmin802/sangmin802.github.io"}}},"markdownRemark":{"id":"27784ac9-f357-5064-9614-91d7f74ef7d2","excerpt":"…","html":"<p>프론트엔드 개발을 하다보면, 거의 필수적으로 하게되는 작업이 있다.</p>\n<p><strong>비동기 작업</strong></p>\n<p>사용자에게 <code class=\"language-text\">UI</code>를 보여줄 때 대부분 이 비동기 작업을 하여 데이터를 받아오고 필요한 작업을 한 다음 완성된 화면을 보여줬었다.</p>\n<p><code class=\"language-text\">React</code>에서 이러한 비동기 작업을 도와주는 <code class=\"language-text\">Redux-Saga</code>와 같은 모듈이 있을 정도로 중요하게 자리잡고 있는 부분이다.</p>\n<blockquote>\n<p>사실 <code class=\"language-text\">Redux-Saga</code>를 사용하지 않고 기본 <code class=\"language-text\">Hook</code>들 만으로도 가능해지긴 했다.</p>\n</blockquote>\n<h2 id=\"-늘-작업해오던-대로\" style=\"position:relative;\"><a href=\"#-%EB%8A%98-%EC%9E%91%EC%97%85%ED%95%B4%EC%98%A4%EB%8D%98-%EB%8C%80%EB%A1%9C\" aria-label=\" 늘 작업해오던 대로 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🍝 늘 작업해오던 대로</h2>\n<p>아래와 같은 방식 혹은 종종 <code class=\"language-text\">Redus-Saga</code>로 늘 비동기 작업을 해왔었다.\n사실 두가지 방법 또한, 필수·수동적으로 해줘야 하는 작업이 있었다.</p>\n<ol>\n<li><code class=\"language-text\">pending</code> 상태일 때, 사용자에게 보여질 <code class=\"language-text\">UI</code> 구성</li>\n<li><code class=\"language-text\">catch</code>로 에러의 상태가 넘어갔을 때의 에러 핸들링</li>\n<li>작업 완료 후, 상태값 변경</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> fetchData <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setLoading</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">setLoading</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>setLoading<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">,</span> setState<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>fetchData<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>또한, 위의 비동기작업을 겨처서 받아오는 데이터를 사용하는 컴포넌트에서도 늘 동일하게 보이는 코드들이 있었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>isLoading<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>LoadingSpinner <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n\n<span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&lt;</span>감싸는 태그<span class=\"token operator\">></span>\n    <span class=\"token punctuation\">{</span>data <span class=\"token operator\">?</span> <span class=\"token operator\">&lt;</span>정상 렌더링 <span class=\"token operator\">/</span><span class=\"token operator\">></span> <span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span>비정상 렌더링 <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>감싸는 태그<span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>데이터를 사용하여 만드는 컴포넌트에서 데이터가 존재하지 않고있음에 따른 렌더링도 별도로 해줘야 하는 점.</p>\n<p>물론 <code class=\"language-text\">data?.something</code> 과 같이 최근 <code class=\"language-text\">ES</code>시리즈를 통해 비교적 양호해지긴 했지만, 기본 컴포넌트의 목적에 벗어나는 다른 상황의 렌더링도 고려해야하는것은 여전히 존재했다.</p>\n<p>심지어, 비동기작업을 통해 발생하는 에러에 있어서는 핸들링을 하는데에 매우 불편함이 있었다.</p>\n<p>따라서 <code class=\"language-text\">React</code> 기본 모듈과 그 외부 모듈들을 통해 이 불편함을 해소해보려 한다.</p>\n<h2 id=\"-react-query\" style=\"position:relative;\"><a href=\"#-react-query\" aria-label=\" react query permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🥪 React-Query</h2>\n<p><code class=\"language-text\">React-Query</code>의 공식문서에서 설명되는 바로는 <code class=\"language-text\">React</code>에서 서버상태를 가져오고, 캐싱, 동기화, 업데이트하는 작업을 쉽게 수행할 수 있도록 도와주는 모듈이라고 나와있다.</p>\n<p>기본적으로 <code class=\"language-text\">React</code>에서는 지금까지 위에서 해왔던 것처럼 개발자가 직접 비동기 작업 환경을 구성해주었어야 했다.</p>\n<p>아직 어마어마하게 큰 규모의 애플리케이션을 제작하고, 운영해본 경험은 없었어서 위의 방법도 크게 불편하다는 생각을 느끼지는 못했었다.</p>\n<p>하지만, 이후 추가적인 장점들이 있었는데</p>\n<ol>\n<li>캐싱</li>\n<li>오래된 데이터 업데이트</li>\n<li>데이터의 유효기간 설정</li>\n</ol>\n<p>위의 기능들에 큰 매력을 느끼게 되었다.</p>\n<h3 id=\"-setting\" style=\"position:relative;\"><a href=\"#-setting\" aria-label=\" setting permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌮 Setting</h3>\n<p>기본적인 사용으로는 <code class=\"language-text\">Redux</code>, <code class=\"language-text\">Router</code>, <code class=\"language-text\">StyledComponent</code>의 <code class=\"language-text\">Provider</code>처럼 상위 <code class=\"language-text\">App</code>을 감싸주고 <code class=\"language-text\">client</code> 속성을 부여해준다.</p>\n<p><code class=\"language-text\">React-Query</code> 비동기 작업들이 실행될 백그라운드를 생성해주는 작업이라고 한다.</p>\n<p>또한, <code class=\"language-text\">ReactQueryDevtools</code>을 통해 생성된 <code class=\"language-text\">query</code>들의 상태들을 확인해 볼 수 있는 개발도구도 제공해주고 있었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> QueryClientProvider<span class=\"token punctuation\">,</span> QueryClient <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react-query'</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> ReactQueryDevtools <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react-query/devtools'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> queryClient <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">QueryClient</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">defaultOptions</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">queries</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">retry</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">suspense</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token operator\">&lt;</span>QueryClientProvider client<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>queryClient<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>ReactQueryDevtools initialIsOpen<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>QueryClientProvider<span class=\"token operator\">></span></code></pre></div>\n<p>이후, 필요한 곳에서 <code class=\"language-text\">hook</code>처럼 가져다 사용을 하면 되는데 필요한 인자들이 있다.</p>\n<ol>\n<li><code class=\"language-text\">key</code> : 해당 <code class=\"language-text\">query</code>가 갖게되는 고유한 <code class=\"language-text\">key</code>인데, 이후 해당 <code class=\"language-text\">query</code>에 직접 접근할 때 필요하니 <code class=\"language-text\">유저 검색</code>과 같이 다른 값들이 참조되는 경우에 꼭 구분되도록 해주는게 좋다.</li>\n<li><code class=\"language-text\">asyncFunction</code> : 실제 작업될 비동기 함수.</li>\n<li><code class=\"language-text\">options</code> : 재시도횟수, 캐싱 시간, 최신 데이터로 인정하는 시간 등 을 설정해 줄 수 있다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> data <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useQuery</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">asyncFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">retry</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>해당 <code class=\"language-text\">query</code>는 캐싱되어있는 데이터가 오래되거나, 참조하고 있는 <code class=\"language-text\">key</code>가 변경될 때 재실행되어 비동기작업을 다시 호출한다.</p>\n<p>신기한점이, <code class=\"language-text\">suspense: true</code> 라는 속성을 통해서 <strong>비동기작업이지만 데이터가 존재하지 않는 상황은 고려하지 않게된다</strong></p>\n<p>다소 이해가 안되는 말일수 있는데 위에서 불편하다고 생각했던 컴포넌트가 사용하는 데이터가 존재하지 않는 경우 별도로 진행하는 렌더링 구문을 작성할 필요가 없어지는 것이다.</p>\n<h3 id=\"-컴포넌트-렌더링-외의-상황에대한-고려-제거\" style=\"position:relative;\"><a href=\"#-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%99%B8%EC%9D%98-%EC%83%81%ED%99%A9%EC%97%90%EB%8C%80%ED%95%9C-%EA%B3%A0%EB%A0%A4-%EC%A0%9C%EA%B1%B0\" aria-label=\" 컴포넌트 렌더링 외의 상황에대한 고려 제거 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌯 컴포넌트 렌더링 외의 상황에대한 고려 제거</h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">useEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">data</span><span class=\"token operator\">:</span> eventData <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useQuery</span><span class=\"token punctuation\">(</span>\n    <span class=\"token string\">'fetchEventData'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">API</span><span class=\"token punctuation\">.</span><span class=\"token function\">getEventData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">refetchOnWindowFocus</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">return</span> eventData\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이벤트 데이터를 사용해야 하는 컴포넌트이다.</p>\n<p>본래 이전과 같았다면, 첫 렌더링 때에는 <code class=\"language-text\">eventData</code>가 존재하지 않기 때문에 그에 따른 렌더링을 따로 정의해주거나, <code class=\"language-text\">eventData?.events</code>와 같은 처리를 해주었어야 했지만 <code class=\"language-text\">useQuery</code>의 <code class=\"language-text\">suspense</code>를 사용하여 그러한 구문들을 사용하지 않아도 에러가 발생하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Event</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> eventData <span class=\"token operator\">=</span> <span class=\"token function\">useEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>Styled<span class=\"token punctuation\">.</span>Content type<span class=\"token operator\">=</span><span class=\"token string\">\"event\"</span><span class=\"token operator\">></span>\n      <span class=\"token punctuation\">{</span>eventData<span class=\"token punctuation\">.</span>events<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event<span class=\"token punctuation\">,</span> index</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n        <span class=\"token operator\">&lt;</span>Styled<span class=\"token punctuation\">.</span>Event key<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">event</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>index<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n          <span class=\"token operator\">&lt;</span>Event event<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>event<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Styled<span class=\"token punctuation\">.</span>Event<span class=\"token operator\">></span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Styled<span class=\"token punctuation\">.</span>Content<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>기본적으로 <code class=\"language-text\">useQuery</code>를 사용하게 될 경우, 해당 <code class=\"language-text\">query</code>를 통해 데이터가 완전히 받아와지지 않았다면 컴포넌트 자체를 <code class=\"language-text\">mount</code> 하지 않아서 데이터가 존재하지 않는 상황이 아예 없게 구성하는것 같았다.</p>\n<blockquote>\n<p>데이터가 없는 상황이 고려대상에서 사라짐</p>\n</blockquote>\n<h3 id=\"-데이터-캐싱-및-최신화\" style=\"position:relative;\"><a href=\"#-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%BA%90%EC%8B%B1-%EB%B0%8F-%EC%B5%9C%EC%8B%A0%ED%99%94\" aria-label=\" 데이터 캐싱 및 최신화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🥙 데이터 캐싱 및 최신화</h3>\n<p>데이터를 처음 받게되면 두가지 3가지의 상태를 가질수 있게 된다.</p>\n<ol>\n<li><code class=\"language-text\">fresh</code> : 아직 최신의 데이터로 데이터를 새로 받아올 필요 없음</li>\n<li><code class=\"language-text\">stale</code> : 오래된 데이터라서 특정 상황에 새로운 데이터를 받아와야 함</li>\n<li><code class=\"language-text\">cache</code> : 새로운 데이터를 받아올 때, 보여줄 캐싱된 데이터</li>\n</ol>\n<p>위 상태로 전환되는 시간들 또한 직접 조절할 수 있다.</p>\n<ul>\n<li><code class=\"language-text\">cachTime</code> : 캐싱시간</li>\n<li><code class=\"language-text\">staleTime</code> : <code class=\"language-text\">fresh</code>에서 <code class=\"language-text\">stale</code>상태로 넘어가게되는 최소시간</li>\n</ul>\n<p>모든 시간은 밀리세컨드를 기준으로 작성해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> queryClient <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">QueryClient</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">defaultOptions</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">queries</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">retry</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">suspense</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">cacheTime</span><span class=\"token operator\">:</span> <span class=\"token number\">1000</span> <span class=\"token operator\">*</span> <span class=\"token number\">60</span> <span class=\"token operator\">*</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">staleTime</span><span class=\"token operator\">:</span> <span class=\"token number\">1000</span> <span class=\"token operator\">*</span> <span class=\"token number\">60</span> <span class=\"token operator\">*</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>지금은 테스트를 위해 <code class=\"language-text\">staleTime</code>을 <code class=\"language-text\">1초</code>로 바꿔서 진행해보았다.</p>\n<div style=\"text-align : center\">\n  <img src=\"/img/2021/07/07/1.gif?raw=true\" alt=\"1\">\n</div>\n<ol>\n<li>데이터를 받아와서 <code class=\"language-text\">fresh</code></li>\n<li>1초 경과</li>\n<li>데이터가 오래되었다 판단되어 <code class=\"language-text\">stale</code> 상태로 변환</li>\n<li>사용자의 <code class=\"language-text\">focus</code>가 외부에서 해당 앱 내부로 들어왔을 때 다시 <code class=\"language-text\">data fetching</code>\n<blockquote>\n<p>해당 옵션은 <code class=\"language-text\">false</code>, <code class=\"language-text\">true</code>로 변경 가능</p>\n</blockquote>\n</li>\n<li>새로운 데이터를 받아오지만 <code class=\"language-text\">caching</code>되어있는 데이터가 있어서 해당 컴포넌트가 데이터 없음을 감지하지 않고 바로 리렌더링</li>\n</ol>\n<p>위의 순서를 거치게 되는데, 주목할 점은</p>\n<ul>\n<li>데이터가 스스로 오래됨을 분류하고 특정 조건에 새롭게 데이터를 받아온다.</li>\n<li>새롭게 데이터를 받아오는 동안에는 컴포넌트가 오작동되는것이 아닌 이전 <code class=\"language-text\">caching</code>된 데이터를 노출하면서 새로운 데이터를 받아오면 자연스럽게 리렌더링 한다.</li>\n</ul>\n<p>만약, 늘 최신의 상태를 유지해야 하는 데이터가 아니라면, 사용자에게 불필요한 로딩시간을 줄여주고 계속해서 화면을 볼 수 있다는점은 정말 좋은 유저경험을 제공하게 될 것 같다.</p>\n<p>간단한 예시로 <code class=\"language-text\">useQuery</code>만을 사용했는데, 해당 공식문서에는 <code class=\"language-text\">infiniteScroll</code>과 같은 스크롤 할 때마다 새로운 데이터를 받아와 기존 데이터와 합쳐서 렌더링하는 <code class=\"language-text\">infiniteQuery</code>와 같은 여러 상황에 맞는 <code class=\"language-text\">query</code>들이 있어서 필요에 따라 사용하면 좋을것 같다.</p>\n<h2 id=\"-에러-핸들링과-pending-ui\" style=\"position:relative;\"><a href=\"#-%EC%97%90%EB%9F%AC-%ED%95%B8%EB%93%A4%EB%A7%81%EA%B3%BC-pending-ui\" aria-label=\" 에러 핸들링과 pending ui permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🧆 에러 핸들링과 pending UI</h2>\n<p>비동기작업이여도 캐싱을 통해 사용자에게 좋은 경험을 줄 수 있는 <code class=\"language-text\">React-Query</code>를 경험해 보았다.</p>\n<p>또한 데이터를 받을 때, <code class=\"language-text\">suspense : true</code> 속성을 통해 아직 데이터를 받지 못한 <code class=\"language-text\">pending</code> 상태라면 이후의 렌더링을 중지하는 듯한 기능을 사용할 수 있었다.</p>\n<p>하지만, 아직 그 <code class=\"language-text\">pending</code>상태로 렌더링이 중지되었을 때 이후의 처리와 에러핸들링에 대한 고민은 남아있었다.</p>\n<p>이 또한, <code class=\"language-text\">React-Query</code>와 <code class=\"language-text\">React</code>에서 새롭게 소개되고있는 <code class=\"language-text\">Suspense</code>, <code class=\"language-text\">ErrorBoundary</code>로 해결 할 수 있었다.</p>\n<p>따라서 다음에 기존 프로젝트에 이 기능들을 반영한 경험을 복기하며 다시 정리해볼 생각이다.</p>","frontmatter":{"title":"⚛ React-Query를 사용하여 효율적인 비동기 처리하기","date":"July 07, 2021"}}},"pageContext":{"slug":"/Study/Think/react-query/","previous":{"fields":{"slug":"/Study/DataStructure/programmers_18_dfs&bfs/"},"frontmatter":{"title":"여행경로-DFS/BFS","category":"Study","draft":false,"tag":"Programmers Coding Test"}},"next":{"fields":{"slug":"/Study/Think/suspense/"},"frontmatter":{"title":"⚛ React.Suspense를 사용하여 비동기 Pending 관리하기","category":"Study","draft":false,"tag":"Think"}}}},"staticQueryHashes":["1162990174","1854831582","2054357557","3128451518"],"slicesMap":{}}