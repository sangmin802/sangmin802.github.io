{"componentChunkName":"component---src-templates-blog-post-js","path":"/Study/Think/browser-operation/","result":{"data":{"site":{"siteMetadata":{"title":"SangMin 개발 이야기","author":"SangMin","siteUrl":"https://sangmin802.github.io","comment":{"disqusShortName":"","utterances":"sangmin802/sangmin802.github.io"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"ec8ab13f-6e11-5c6f-8cd9-88ebe66039e0","excerpt":"Operation 과 를 결합하여 오로지 화면에 될 요소들만 남긴 를 형성하였다. 이제, 이 를 속성에 맞게 화면에 하는데까지의 과정을 살펴보자 Layout 의 요소인 각 들의 뷰포트 내에서 크기, 위치 등의 구조들을 계산하여 을 생성한다. 스크롤을 하여 변화된 뷰포트 기준으로 새롭게 위치값을 계산해야하거나, 직접적으로 DOM의 위치값에 변화를 주었을 때, 다시 계산하게되는데 이러한것을  라고 한다. Painting…","html":"<h2 id=\"operation\" style=\"position:relative;\"><a href=\"#operation\" aria-label=\"operation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Operation</h2>\n<div style=\"margin : 0 auto; text-align : center\">\n  <img src=\"/img/2021/07/27/operation1.PNG\" alt=\"1\">\n</div>\n<p><code class=\"language-text\">CSSOM</code>과 <code class=\"language-text\">DOM Tree</code>를 결합하여 오로지 화면에 <code class=\"language-text\">render</code>될 요소들만 남긴 <code class=\"language-text\">Render Tree</code>를 형성하였다.</p>\n<p>이제, 이 <code class=\"language-text\">Render Tree</code>를 속성에 맞게 화면에 <code class=\"language-text\">render</code>하는데까지의 과정을 살펴보자</p>\n<h2 id=\"layout\" style=\"position:relative;\"><a href=\"#layout\" aria-label=\"layout permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Layout</h2>\n<div style=\"margin : 0 auto; text-align : center\">\n  <img src=\"/img/2021/07/27/operation2.png\" alt=\"2\">\n</div>\n<p><code class=\"language-text\">Render Tree</code>의 요소인 각 <code class=\"language-text\">Node</code>들의 뷰포트 내에서 크기, 위치 등의 구조들을 계산하여 <code class=\"language-text\">layout</code>을 생성한다.</p>\n<p>스크롤을 하여 변화된 뷰포트 기준으로 새롭게 위치값을 계산해야하거나, 직접적으로 DOM의 위치값에 변화를 주었을 때, 다시 계산하게되는데 이러한것을 <code class=\"language-text\">reflow</code> 라고 한다.</p>\n<h2 id=\"painting\" style=\"position:relative;\"><a href=\"#painting\" aria-label=\"painting permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Painting</h2>\n<p><code class=\"language-text\">Layout</code>단계에서 <code class=\"language-text\">Render Tree</code> 요소들의 크기, 구조등을 계산하여 <code class=\"language-text\">layout</code>을 만들었다.</p>\n<p>하지만, 이러한 기하학적인 요소만으로는 화면이 완성되었다고 할 수 없다.</p>\n<p><code class=\"language-text\">문서의 구조</code>, <code class=\"language-text\">각 요소의 스타일</code>, <code class=\"language-text\">페이지의 기하학 구조</code>, <code class=\"language-text\">그릴 순서</code>를 알았으니, 페이지를 렌더링할 수 있다.\n이러한 정보들을 스크린의 픽셀로 바꾸는것을 <strong>레스터화</strong>라고 한다.</p>\n<p>이렇게 위치값과같은 기하학적인 요소는 변화가 없지만, 색상과같은 변화가 다시 발생하는것을 <code class=\"language-text\">repaint</code>라고 한다.</p>\n<h2 id=\"composition\" style=\"position:relative;\"><a href=\"#composition\" aria-label=\"composition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composition</h2>\n<p>위와같이 스크롤을 하여 뷰포트가 변경되는등 자연스럽게 발생하는 <code class=\"language-text\">reflow</code>등에 대한 렌더링 최적화를 위해 추가된 방법이다.</p>\n<p>이전에는 스크롤을 하여서 페이지 내부에서 뷰포트가 하단으로 이동하였을 때, 새롭게 화면을 그려냈다. 그런데 문제는, 요소에 변경이 있다면 그 위치값을 다시계산하기 위해 <code class=\"language-text\">reflow</code>가 발생하는 점 이였다.</p>\n<div style=\"margin : 0 auto; text-align : center\">\n  <img src=\"/img/2021/07/27/parser-blocking1.png\" alt=\"1\">\n</div>\n<p>렌더링을 해야하는 페이지에서 각각의 요소들을 모두 분리하고 미리 <code class=\"language-text\">Layer</code>로 나누어서 관리한다.</p>\n<p>각각의 요소들이 모두 분리되어서 관리되기 때문에, 위치가 변경된다고 해서 다른 레이어에 영향을 주지 않는다.</p>\n<p><code class=\"language-text\">Layer Tree</code>가 생성되고 페인트 순서는 이전단계에서 알고 있기 때문에 메인스레드는 해당 정보들을 <strong>컴포지터 스레드</strong>에게 전달해준다</p>\n<p>그럼 컴포지터 스레드는 각 레이어들을 레스터라이즈(레스터화)를 시도 한다.</p>\n<p>하지만, 생성된 레스터화 하려는 <code class=\"language-text\">Layer</code>의 크기가 어마어마하게 클 수 있기 때문에 컴포지터 스레드는 <code class=\"language-text\">Layer</code>을 여러개의 조각으로 쪼개서 다수의 <strong>레스터 스레드</strong>에게 레스터화 작업을 위임한다.</p>\n<p>이때, 컴포지터 스레드는 레스터 스레드들에게 작업을 위임하면서 우선순위를 정해줄 수 있어, 화면에서 보여야 하는 것들을 먼저 레스터화 하도록 시킬 수 있다.</p>\n<p>여러개의 조각들이 레스터 스레드에서 레스터화가 완료되면, 컴포지트 스레드는 화면에 포여질 조각들만 모아서 렌더링 하도록 전달을 해준다.</p>\n<p>만약 스크롤이 발생하여 보여질 화면이 변경된다거나, 각각의 요소들의 위치와 같은 속성들이 변경되는 상황에는 <code class=\"language-text\">Layout Tree</code>를 재구성할 필요 없이, <code class=\"language-text\">composition</code> 단계에서 <code class=\"language-text\">Layer</code>들을 재조합해주기만 하면 된다.</p>\n<p>이 뜻은, 메인 스레드가 작동될 필요 없이, 컴포지터 스레드에서만의 작업으로 렌더링을 할 수 있다는 점이다.</p>\n<ul>\n<li>실제로, 애니메이션 속성을 부여할 때, <code class=\"language-text\">width</code>을 변경하면 <code class=\"language-text\">alert</code>를 사용하여 중단시켰을 때, 애니메이션도 중지되지만, <code class=\"language-text\">transform</code> 속성을 사용하면 <code class=\"language-text\">alert</code>이 활성화 되어도 중지되지 않고 끝까지 진행된다.(비동기같음)</li>\n</ul>\n<p>위에서 화면의 각 요소들을 <code class=\"language-text\">Layer</code>로 관리하고, 메인 스레드에서의 작업을 컴포지션 스레드에 위임하여 렌더링 비용을 절약할 수 있다고 했다.</p>\n<p>하지만, 모든 상황에서 위와 같은 최상의 렌더링 효율을 낼 수 있는 <code class=\"language-text\">CSS</code>속성들은 한정되어 있는것 같다.</p>\n<div style=\"margin : 0 auto; text-align : center\">\n  <img src=\"/img/2021/07/27/operation3.jpg\" alt=\"3\">\n</div>\n<p>요소의 우선순위나 색상, 보여지는 여부등을 변경하지 않는 속성들이 대부분이다.</p>\n<ul>\n<li>opacity : <code class=\"language-text\">Render Tree</code> 형성 단계에서, <code class=\"language-text\">display : none</code>은 <code class=\"language-text\">0px 0px</code>로 제외되지만, <code class=\"language-text\">Opacity</code>속성은 공간은 차지하는 상태라고 했었음</li>\n<li>transform(translate, scale, rotate) : 요소의 위치 혹은 고유 크기, 디자인을 해치지 않고 고유의 모양만 변경되는 <code class=\"language-text\">CSS</code> 속성</li>\n</ul>\n<h2 id=\"렌더링-성능-개선\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%84%B1%EB%8A%A5-%EA%B0%9C%EC%84%A0\" aria-label=\"렌더링 성능 개선 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더링 성능 개선</h2>\n<p>렌더링 시간이 길어지게되면, 사용자에게 부적절한 사용경험을 남기게 될 수 있다.</p>\n<p>사용자가 요청을하고 최종 렌더링이 될 때 까지의 시간을 가능한 단축시켜서 빠르게 화면을 접할 수 있도록 하는것이 중요하다.</p>\n<p><code class=\"language-text\">Render Tree</code>를 형성하기까지의 구간을 <code class=\"language-text\">Construction</code>, <code class=\"language-text\">Layout</code>단계부터 <code class=\"language-text\">Composition</code>까지 <code class=\"language-text\">Operation</code>이라고 했었다.</p>\n<h2 id=\"construction\" style=\"position:relative;\"><a href=\"#construction\" aria-label=\"construction permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Construction</h2>\n<p>날것의 파일을 브라우저가 이해할 수 있고 사용할수 있는 언어로 바꾸는 작업을 한다.</p>\n<p>사실 이 구간에서는 <strong>불필요한 태그 사용</strong>을 하지 않는것이 최선이라 볼 수 있을것 같다.</p>\n<h3 id=\"reflow\" style=\"position:relative;\"><a href=\"#reflow\" aria-label=\"reflow permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reflow</h3>\n<p>브라우저가 <code class=\"language-text\">layout</code>, <code class=\"language-text\">paint</code>, <code class=\"language-text\">composition</code> 즉, <code class=\"language-text\">Operation</code>의 모든 단계를 다시 실행하여 우선순위, 고유 크기 등이 변경되는 상황이다.</p>\n<blockquote>\n<p><code class=\"language-text\">display</code>, <code class=\"language-text\">position</code>, <code class=\"language-text\">width</code> 등등</p>\n</blockquote>\n<h3 id=\"repaint\" style=\"position:relative;\"><a href=\"#repaint\" aria-label=\"repaint permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Repaint</h3>\n<p><code class=\"language-text\">paint</code>와 <code class=\"language-text\">composition</code> 단계만 재실행 되는 경우를 의미한다.</p>\n<blockquote>\n<p><code class=\"language-text\">background-color</code>, <code class=\"language-text\">box-shadow</code> 등등</p>\n</blockquote>\n<p>브라우저별로 <code class=\"language-text\">css</code> 속성과 관련되어 어느 수준의 단계부터 다시계산되어야 하는지 보여주는 사이트가 있다.</p>\n<ul>\n<li><a href=\"https://csstriggers.com/\">css triggers</a></li>\n</ul>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<p>브라우저의 렌더링 과정과, 성능개선에 대해 알아보았다.</p>\n<p>처음 <code class=\"language-text\">HTML Parsing</code>부터 <code class=\"language-text\">Composition</code>까지 브라우저를 렌더링하는 모든 단계들을 <code class=\"language-text\">CRP - Critical Rendering Path</code> 라고 한다.</p>\n<blockquote>\n<p>이전, <code class=\"language-text\">CRP</code>가 중단되는 상황을 설명했던 포스트에서의 그 <code class=\"language-text\">CRP</code>다</p>\n</blockquote>\n<p>그중에서도, 렌더링 최적화에있어서 여러부분에 놀라게되었는데, 현재 사용하고 있는 방식들 중 몇몇부분은 <code class=\"language-text\">operation</code>단계에서 많은 비용이 사용되고 있다는 점 이였다.</p>\n<p>이 문제에 대해서 개선해봐야할 것 같다.</p>\n<blockquote>\n<p>아래 <code class=\"language-text\">LogRocket</code> 블로그에서는 테스트 방법도 나와있으니 해봐야할듯!</p>\n</blockquote>\n<h2 id=\"참조\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EC%A1%B0\" aria-label=\"참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참조</h2>\n<ul>\n<li><a href=\"https://sangcho.tistory.com/entry/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98Rendering2Operation?category=740188\">operation</a></li>\n<li><a href=\"https://developers.google.com/web/updates/2018/09/inside-browser-part3\">modern web browser</a></li>\n<li><a href=\"https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/\">high performance animations</a></li>\n<li><a href=\"https://blog.logrocket.com/eliminate-content-repaints-with-the-new-layers-panel-in-chrome-e2c306d4d752/\">LogRocket - repaint</a></li>\n<li><a href=\"https://devsdk.github.io/ko/development/2021/03/29/blink-render-composition.html\">composite</a></li>\n</ul>","frontmatter":{"title":"💻 브라우저 렌더링 - 시각화 단계 operation","date":"July 27, 2021"}}},"pageContext":{"slug":"/Study/Think/browser-operation/","previous":{"fields":{"slug":"/Study/Think/browser-parser-blocking/"},"frontmatter":{"title":"💻 브라우저 렌더링 - CRP 멈춰!","category":"Study","draft":false,"tag":"Think"}},"next":{"fields":{"slug":"/Study/Think/abstract painting/"},"frontmatter":{"title":"⚛ 선언적인 컴포넌트로 추상화, 그리고 수준의 통일","category":"Study","draft":false,"tag":"Think"}}}},"staticQueryHashes":["3128451518","3665928227","479399088","479399088"]}