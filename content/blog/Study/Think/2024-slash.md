---
title: toss slash 2024
date: 2025-01-01 19:00:00
category: 'Study'
draft: true
tag: 'Think'
---

Slash2024

# 오프라인 결제를 빠르고 안정적으로 혁신하는 방법

매장이나 식당에서 흔히 볼 수 있는 고객 테이블 별 주문기와, 결제기와의 내용임
테이블별 주문기를 토스프론트
결제기를 토스포스

## 하루에도 수십번 배포가 가능했던 이유

빠른 배포가 중요했음. 오프란인 결제는 첫 도전이고, 많은 실험이 필요하며 많은 실험을 위해서는 빠른 배포 속도가 필요했음

Electron 앱을 썼는데, 작은 변경에도 전체가 다시빌드되어야 했고 chrome이 내장되어있어서 100mb의 다운로드 용량이 있었고 20분정도 걸림

단순 버튼수정만 있어도 html, css, js만 변경되었는데 chrome 브라우저의 렌더러프로세스, 메인프로세스 모두 다시빌드함

electron의 chrome 브라우저와 관련된 렌더러프로세스, 메인프로세스는 사실 변경빈도가 거~의 없고 html, css, js 부분만 변경이 잦았음.

이 html, css, js 영역(이후 webview bundle이라 함)을 별도로 분리해서 cdn에 따로 분리하여 배포함.

이후, electron에서는 이 webview bundle을 가져와서 사용하도록 하면, 이 변경사항이 잦은 webview bundle만 수정해서 배포한다면 electron 서비스 자체를 다시 빌드할 필요가 없음

토스는 각 부서별로 독립적인 배포체계를 가지고 있어서 서로의 서비승 영향을 주지 않아야 하기 때문에 마이크로 프론트엔드 아키텍처를 사용함
토스 앱 전체탭을 보면 많은 서비스들이 있지만, 이 서비스들을 독립적으로 운영함.

토스 포스 또한 내부 여러개의 서비스가 생겼고, 동일한 구성을 가져감
—> 주문, 결제, 시재관리를 각각의 webview bundle로 나누어서 관리함

안드로이드, iOS의 패드환경에서도 사용하고싶다는 피드백이 있었는데, 이 경우에도 위 webview bundle로 분리한것이 이점이 있었음
기존 electron은 window. macOS만 지원되지만 electron이 아닌 android, iOS 기준의 프레임워크를 사용하고 위 webview bundle만 똑같이 다운받아와서 쓰면 됨

electron이 아닌 android, iOS 구성을 위한 native 구현 비용이 더 생기는데 안삐삼?
사실 서비스 운영을 위한 비즈니스로직은 webview bundle안에만 있기 때문에 거의 건들 일이 없고, 비싸지도 않음

Window, Mac, iOS, android 환경에 맞는 코드를 위해서 webviewbundle, native에 각각 서로를 잇는 브릿지인 toss api를 구성함webview bundle에는 toss pos bridge, native에는 toss pos api
Webview bundle에서는 이 브릿지에서 제공해주는 동일한 api를 사용하고, 각 native 환경에 맞는 방식으로 구현, 변환해주는것 같음

electron과 같이 서비스 틀이 될 프레임워크와 별개로 변경이 잦은 html, css, js를 엮은 번들을 분리하여 걔만 배포

## 수십만건의 안정적인 결제

물리적으로 떨어져있는 포스와 프론트간 수많은 결제 요청을 어떻게 안정적으로 처리할까

### 연결 안정성 - 유선연결

유선 연결의 경우 물리적 간섭으로 데이터유실, 누락가능성이 존재함. 정전 등등

Toss serial prot protocol을 구성함
딴거 생각 없이, http 통신 할 때 TCP/IP 프로토콜을 통해 신뢰성있는 요청을 위해 일종의 규칙이 있는것처럼 동일한것을 클라이언트 단에서 구성했다고 생각

Data: 데이터, ack: 데이터 전송 성공, nak: 데이터 전송 실패 패킷으로 구성되어있음

신뢰성 검사에 실패하면 nak을 전송, 성공하면 ack를 전송
정전과 같은 데이터 유실의 경우에 대비해 timeout룰 적용

### 연결 안정성- 무선연결

양방향 통신을 위해 웹소킷을 사용
wifi가 끊기면..?
연결이 끊기면 모든 ip를 다 호출해서 찾는거임. 마지막 그룹만 탐색하더라도 256번을 찾아야 함

broadcasting을 사용해 토스프론트는 자신의 ip주소를 알려줌
토스포스가 저 ip주소를 받아서 웹소킷 재연결

결과적으로 유선연결의 경우 물리적 불안전성(정전 등) 데이터가 온전히 갔는지, 잘 받았는지 검증을 위해 TCP/IP처럼 별도 클라이언트 프로토콜을 만들어서 연결 안정성을 체크했으며
무션연결의 경우 ip가 자주 바뀌고 끊기는 경우에도 broadcast를 통해 토스프론트가 본인의 ip 주소를 알려 토스포스에서 재요청 할 수 있도록 DNS-SD를 사용

결제는 절대로 문제가 발생하면 안됨.
결제요구사항이 많아질수록 코드가 많아지고 어려워짐

아떻게 안전하고 확장성있게 만들까

결제의 시점에 따른 관심사로 코드를 분리함
주문 전 동작, 주문 후 동작, 결제 후 동작 이렇게 시점으로 구분함

결제의 생명주기 정의할 수 있게 됨
beforeOrder, afterOrder etc..

생명주기가 생기다보니 결제 플러그인을 만들 수 있도록 됨

결제코드를 위와같이 플러그인 구조를 도입하여, 복잡도를 낮추고 수정이 있더라도 각 결제 기능 플러그인에 결제 시점별 코드가 분리되어있어 다른곳에 영향을 주지 않고 개발이 용이했음

# React Native 디버깅

Isomorphic 라이브러리를 통해 react react native 간 동일한 개발경험을 하고자 함

단, 플랫폼이 다르다보니 디버깅이 다름

react를 통한 브라우저 개발은 그냥 브라우저 개발자도구를 통해 디버깅함

단, react native는 내장되어있는 개발자도구가 없어서 filpper라는 도구를 통해 디버깅을 함. 기본적인 디버깅을 제공함. 필요하다면 플러그인으로 확장 가능

하지만.. flipper는 electron 서비스라 무겁고 자잘한 버그가 많음제품의 빠른 개발과 테스트를 저하시킴.

오픈소스 chrome dev tools frontend 기반 실험적 기능으로 새로운 디버깅 도구가 탄생함
크로미움 기반의 브라우저는 Chrome dev tools protocol(이후 cdp라 함)을 기반으로 동작함
요소집기, 스타일찾기 등 디버깅이 가능했음

개발자도구에서 추가적인 설정을 켜야 활성화되는데설정 -> experimentals -> protocol monitor 메뉴 활성화

근데 이걸 react native에서는 어떻게?
이미 react native core에는 이 기능을 사용하고 있었음

근데 기기와 브라우저의 개발자도구간 어떻게 소통할까?
React native 서버에는 웹소킷을 통해 메시지를 브라우저에 보내는 등 소통함

다 좋긴 한데, 아직 네트워크 확인 기능은 지원되지 않았음

그래서 chrome dev tools frontend 오픈소스를 기반으로 네트워크 확인 기능을 직접 추가하고자 함
Android, iOS 네이티브에서 네트워크를 직접 가로채고, 직접 cdp 메시지를 전송하는 인터셉터를 구현
Cop 사양 중 requestWillBeSent, responseReceiced, loadingFinished를 사용함

1. React native 코어에서 수행되는 네트워크 작업을 가로채고, 요청 응답을 통해 cdp 메시지를 구성
2. 웹소킷을 통해 브라우저 개발자도구로 전달함

React native android에서는 네트워크 작업을 수행하기 위해 http3 클라이언트를 사용하는데, 이 클라이언트 인스턴스를 확장할 수 있었음.
setCustomClientBuilder를 통해, 커스텀 인터셉터를 등록해 react-native 내에서 수행되는 네트워크 요청을 가로챌 수 있었음
Request, response를 가로챌 수 있었고, 이것을 cdp 메시지로 전달함

React native ios는 urlsession을 통해 네트워크 통신을 함
URLprotocol을 사용하여 네트워크를 가로챌 수 있었음

개발자도구 응답 데이터 미리보기를 위해서 추가 구현이 필요했음
preview탭 진입 시, Network.getResponseBody를 요청을 하고, responseData를 받아서 보여주는 방식

1. native에서 네트워크 응답으로 받은 데이터를 커스텀 메시지로 구성
2. 전달받은 데이터는 웹소킷 프록시 서버에 저장
3. 개발자도구로부터 네트워크 요청이 있었음을 수신했다면 위 저장한 데이터를 응답해줌
   1. 근데 여기 개발자도구로부터 네트워크 요청은 어떻게 있는거임? 이거 확인 못한다며

# yarn plugin으로 로깅하기

화면이 열리고, 어떤 요소가 보이는지, 어떤 요소를 눌렀는지 모두 로그를 남김
우리 키네시스 로그 쏘는것처럼..
광고노출분석, 사용자수분석 등등..

수동으로 처리하기에는 너무 많은 로그가 있음..
토스의 디자인 시스템을 통해 pm, 개발자, 디자인 간 모두 인지하고 있는 디자인 시스템 컴포넌트를 기준으로 로그를 자동화해볼 수 있었음

## 그냥 디자인 시스템 안에 로그로직 넣기

하지만.. 토스 증권, 토스뱅크, 페이먼츠, 협력사 등등 토스 디자인시스템을 쓰고 있었고 그러다보니 토스 로그로직을 넣을 수 없었음

로그로직을 포함하다보니 로그수정사항 반영을 위해 디자인시스템 전체적인 업데이트가 필요했음

## HOC로 디자인시스템 컴포넌트를 감싸서 로그로직을 거따넣기

디자인시스템 컴포넌트가 아닌 hoc가 적용된 컴포넌트를 쓰도록 변경을 해야했음
모~~~두 바꿔야 함. 너무 많은 수정이 들어감

기존과 동일한 형태로 코드를 작성하며, 디자인시스템, 로그 간 독립 배포가 가능하도록

## 디자인시스템 패키지를 가로채서 로그 hoc가 적용된 컴포넌트로 바꿔줄 수 없을까?사용하는곳에서는 디자인시스템을 import 하지만, 실제로 쓸 때에는 로그 hoc가 감싸진 패키지가 반환되도록 가로채보자

Yarn plugin을 통해 중간에 바꿔줘보자
yarn은 특이하게 기능들이 plugin 형태로 구성되어있음

Yarn install을 해보면
Resolution, fetch, link 3개의 단계가 존재하고 상세히는 안보이지만
Yarn add를 하면
resolution에 추가된 기록, fetch step에 프로젝트에 추가되어 프로젝트 사이즈가 커졌다는 기록이 남음

즉, yarn이 프로젝트를 구성할 때 위 3개의 step이 있고,
Package.json에 패키지이름, 버전이 명시되면
resolution: descriptor를 통해 라이브러리 버전 범위, 깃 출처 확인해서 확정된 버전을 선택함
fetchstep: locator를 통해 위에서 선택된 버전의 라이브러리 위치를 찾아서 다운로드함
linkStep: 패키지들을 연결함 node_modeuls/라이브러리 혹은 .pnp.cjs…

결국 가로채는 과정은 resolution 단계에서 선택될 때 지정한 버전의 로그 hoc가 감싸진 패키지를 보고, 이 패키지는 설정한 버전의 디자인시스템 패키지를 보도록

resolutionStep에서 descriptor(라이브러리의 버전 및 범위 찾기)와 locator(라이브러리 위치 찾기) 수행 가능 여부를 물어보고, 가능하면 처리를 시작함

근데 생각해보니깐 package.json resolution 필드에 디자인시스템 패키지: 로깅 패키지 이렇게 연결하면 버전은 선택 못하긴해도 되긴 할 것같은데a

# n개의 탭, 하나의 웹소켓. Sharedworkder

토스에서는 실시간 데이터를 다루는 경우가 많음
현재가, 등락률 / 채결 알림 등..

웹소킷으로 가져오거나 폴링으로 가져오거나 등등..

토스증권이 앱으로만 접근 가능할 때애는 토스증권계정 하나당 서버와 한개의 소킷만 생성하여 연결하면 되었었음.
근데 pc가 출시된 다음 상황이 달라짐
여러개의 토스증권 탭을 열어서 사용할 수 있게됨
각 탭마다 웹소킷을 가지고 있어 늘어나게 됨.

기존에는 유저 1명 당 1개의 웹소킷
이제는 유저 1명당 n개의 웹소킷이 생성됨

이렇게 많은 웹소킷이 생성되고, 서버와 연결된다면 서버리소스가 너~무많이 필요함

웹소킷 연결을 최소화해보자

포커스된 탭만 웹소킷을 연결한다면?
—> 비활성화된 탭은 실시간데이터를 수신할 수 없음

visibleChange를 통해 보여지고있는 탭만 웹소킷을 연결한다면?
—> 화면에 보여지고만 있으면 생성이라 10개 보여지고있다면? 원점임

탭 당 웹소킷 하나가 아니라 유저가 연 여러개의 탭이 하나의 웹소킷을 보고있다면 좋을텐데
자바스크립트 스레드 외부, 웹 워커를 보자

Dedicated worker: 그 탭에서 사용할수 있는 별도의 스레드
스크립트 메인 스레드와 워크스레드간 전역변수 공유는 불가능하나 postMessage를 통해 통신할 수 는 있음
그 탭에서만 사용할 수 있는 별도의 스레드라 위 문제를 해결할 수 없음

Shared worker: 여러 탭에서 공유할 수 있는 스레드
이전 dedicated worker는 스레드 생성 시 입력했던 경로의 스크립트 파일이 실행되면 각각의 탭에서 스레드를 생성하지만 shared worker는 위와 같이 스레드를 생성하면 하나의 스레드를 바라봄.
스레드의 공유 기준은 동일 출처(프로토콜, 호스트, 모든 도메인이 동일해야 함)이며, 스크립트 파일 경로가 같아야 함

Message channel을 통해 탭과 워커간 통신 가능

Shared workder에서 브라우저의 모든 기능이 사용하는건 아니지만 웹소킷은 가능했음
이 워커에 웹소킷을 생성해서 관리하자

브라우저의 shared worker 지원 범위에 있어 safari와 모바일 브라우저에서는 지원이 안되고있음..
이 경우에는 어떻게..?

Shared worker가 지원되지 않는 경우, dedicated worker를 사용했음. 이 경우 동일 로직을 재사용 할 수 있었음

토스증권 pc는 대상이 pc, 노트북이라 어느정도 다 지원될꺼라 생각함

난관이 좀 있었음

번들링 관련
워커 생성시., 자바스크립트 파일의 경로를 넣는데 이것은 로컬경로가 아니라 서버경로임.
대부분 번들러를 사용할 텐데, 이렇게 번들 이후 이 파일 경로가 변경될 수 있음
다행이도 많은 번들러들이 web worker api를 지원하는 방법을 가이드 해놓음
메모리 누수
탭이 닫힐 경우, 이 탭과 연결된 워커 내 포트 리소스를 정리해주었어야 했음.
포트에 달려있는 이벤트 리스너 등등.. 끊어줘야 하는데…
어떤 탭이 닫혔는지 알 수 있어야 하는데, 알려주지 않음
beforeunloadEvent를 통해 보내줄까? 하지만 이 이벤트는 때로 호출되지 않을 수 있음.
—> 탭을 최소화 한 상태에서 호출 등
근데 탭이 닫히면 meesagePort가 gc 됨 이걸 감지하면?
—> 여러개의 탭을 연결하기 위해 port를 배열에 담아두었기 떄문에, 브라우저에서 이 port가 계속 사용되고있다고 판단함근데 weakRef를 사용해서 배열을 관리하면 weakRef 자체는 사용한다고 판단해도 내부의 값은 사용되지 않는것을 판단할 수 있음, deref로 상태를 조회했을 때 undefined이면 사용되지 않는 것

주기적으로 타이머를 지정해서 deref를 통해 weakRef를 체크함
